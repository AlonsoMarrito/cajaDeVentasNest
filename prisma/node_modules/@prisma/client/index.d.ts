
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model account_s
 * 
 */
export type account_s = $Result.DefaultSelection<Prisma.$account_sPayload>
/**
 * Model client_s
 * 
 */
export type client_s = $Result.DefaultSelection<Prisma.$client_sPayload>
/**
 * Model credit_s
 * 
 */
export type credit_s = $Result.DefaultSelection<Prisma.$credit_sPayload>
/**
 * Model payment_s
 * 
 */
export type payment_s = $Result.DefaultSelection<Prisma.$payment_sPayload>
/**
 * Model sale_s
 * 
 */
export type sale_s = $Result.DefaultSelection<Prisma.$sale_sPayload>
/**
 * Model user_s
 * 
 */
export type user_s = $Result.DefaultSelection<Prisma.$user_sPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Account_s
 * const account_s = await prisma.account_s.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Account_s
   * const account_s = await prisma.account_s.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account_s`: Exposes CRUD operations for the **account_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_s
    * const account_s = await prisma.account_s.findMany()
    * ```
    */
  get account_s(): Prisma.account_sDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client_s`: Exposes CRUD operations for the **client_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_s
    * const client_s = await prisma.client_s.findMany()
    * ```
    */
  get client_s(): Prisma.client_sDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credit_s`: Exposes CRUD operations for the **credit_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credit_s
    * const credit_s = await prisma.credit_s.findMany()
    * ```
    */
  get credit_s(): Prisma.credit_sDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_s`: Exposes CRUD operations for the **payment_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_s
    * const payment_s = await prisma.payment_s.findMany()
    * ```
    */
  get payment_s(): Prisma.payment_sDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale_s`: Exposes CRUD operations for the **sale_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sale_s
    * const sale_s = await prisma.sale_s.findMany()
    * ```
    */
  get sale_s(): Prisma.sale_sDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_s`: Exposes CRUD operations for the **user_s** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_s
    * const user_s = await prisma.user_s.findMany()
    * ```
    */
  get user_s(): Prisma.user_sDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    account_s: 'account_s',
    client_s: 'client_s',
    credit_s: 'credit_s',
    payment_s: 'payment_s',
    sale_s: 'sale_s',
    user_s: 'user_s'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account_s" | "client_s" | "credit_s" | "payment_s" | "sale_s" | "user_s"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      account_s: {
        payload: Prisma.$account_sPayload<ExtArgs>
        fields: Prisma.account_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.account_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          findFirst: {
            args: Prisma.account_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          findMany: {
            args: Prisma.account_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>[]
          }
          create: {
            args: Prisma.account_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          createMany: {
            args: Prisma.account_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.account_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>[]
          }
          delete: {
            args: Prisma.account_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          update: {
            args: Prisma.account_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          deleteMany: {
            args: Prisma.account_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.account_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.account_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>[]
          }
          upsert: {
            args: Prisma.account_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_sPayload>
          }
          aggregate: {
            args: Prisma.Account_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount_s>
          }
          groupBy: {
            args: Prisma.account_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<Account_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_sCountArgs<ExtArgs>
            result: $Utils.Optional<Account_sCountAggregateOutputType> | number
          }
        }
      }
      client_s: {
        payload: Prisma.$client_sPayload<ExtArgs>
        fields: Prisma.client_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          findFirst: {
            args: Prisma.client_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          findMany: {
            args: Prisma.client_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>[]
          }
          create: {
            args: Prisma.client_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          createMany: {
            args: Prisma.client_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.client_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>[]
          }
          delete: {
            args: Prisma.client_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          update: {
            args: Prisma.client_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          deleteMany: {
            args: Prisma.client_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.client_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.client_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>[]
          }
          upsert: {
            args: Prisma.client_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_sPayload>
          }
          aggregate: {
            args: Prisma.Client_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient_s>
          }
          groupBy: {
            args: Prisma.client_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<Client_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_sCountArgs<ExtArgs>
            result: $Utils.Optional<Client_sCountAggregateOutputType> | number
          }
        }
      }
      credit_s: {
        payload: Prisma.$credit_sPayload<ExtArgs>
        fields: Prisma.credit_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credit_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credit_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          findFirst: {
            args: Prisma.credit_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credit_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          findMany: {
            args: Prisma.credit_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>[]
          }
          create: {
            args: Prisma.credit_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          createMany: {
            args: Prisma.credit_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credit_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>[]
          }
          delete: {
            args: Prisma.credit_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          update: {
            args: Prisma.credit_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          deleteMany: {
            args: Prisma.credit_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credit_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.credit_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>[]
          }
          upsert: {
            args: Prisma.credit_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_sPayload>
          }
          aggregate: {
            args: Prisma.Credit_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredit_s>
          }
          groupBy: {
            args: Prisma.credit_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credit_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.credit_sCountArgs<ExtArgs>
            result: $Utils.Optional<Credit_sCountAggregateOutputType> | number
          }
        }
      }
      payment_s: {
        payload: Prisma.$payment_sPayload<ExtArgs>
        fields: Prisma.payment_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          findFirst: {
            args: Prisma.payment_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          findMany: {
            args: Prisma.payment_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>[]
          }
          create: {
            args: Prisma.payment_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          createMany: {
            args: Prisma.payment_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>[]
          }
          delete: {
            args: Prisma.payment_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          update: {
            args: Prisma.payment_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          deleteMany: {
            args: Prisma.payment_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>[]
          }
          upsert: {
            args: Prisma.payment_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_sPayload>
          }
          aggregate: {
            args: Prisma.Payment_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_s>
          }
          groupBy: {
            args: Prisma.payment_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_sCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_sCountAggregateOutputType> | number
          }
        }
      }
      sale_s: {
        payload: Prisma.$sale_sPayload<ExtArgs>
        fields: Prisma.sale_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sale_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sale_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          findFirst: {
            args: Prisma.sale_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sale_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          findMany: {
            args: Prisma.sale_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>[]
          }
          create: {
            args: Prisma.sale_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          createMany: {
            args: Prisma.sale_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sale_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>[]
          }
          delete: {
            args: Prisma.sale_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          update: {
            args: Prisma.sale_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          deleteMany: {
            args: Prisma.sale_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sale_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sale_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>[]
          }
          upsert: {
            args: Prisma.sale_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_sPayload>
          }
          aggregate: {
            args: Prisma.Sale_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale_s>
          }
          groupBy: {
            args: Prisma.sale_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sale_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.sale_sCountArgs<ExtArgs>
            result: $Utils.Optional<Sale_sCountAggregateOutputType> | number
          }
        }
      }
      user_s: {
        payload: Prisma.$user_sPayload<ExtArgs>
        fields: Prisma.user_sFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_sFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_sFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          findFirst: {
            args: Prisma.user_sFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_sFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          findMany: {
            args: Prisma.user_sFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>[]
          }
          create: {
            args: Prisma.user_sCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          createMany: {
            args: Prisma.user_sCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_sCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>[]
          }
          delete: {
            args: Prisma.user_sDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          update: {
            args: Prisma.user_sUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          deleteMany: {
            args: Prisma.user_sDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_sUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_sUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>[]
          }
          upsert: {
            args: Prisma.user_sUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sPayload>
          }
          aggregate: {
            args: Prisma.User_sAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_s>
          }
          groupBy: {
            args: Prisma.user_sGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_sGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_sCountArgs<ExtArgs>
            result: $Utils.Optional<User_sCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account_s?: account_sOmit
    client_s?: client_sOmit
    credit_s?: credit_sOmit
    payment_s?: payment_sOmit
    sale_s?: sale_sOmit
    user_s?: user_sOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Account_sCountOutputType
   */

  export type Account_sCountOutputType = {
    credit_s: number
    sale_s: number
  }

  export type Account_sCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | Account_sCountOutputTypeCountCredit_sArgs
    sale_s?: boolean | Account_sCountOutputTypeCountSale_sArgs
  }

  // Custom InputTypes
  /**
   * Account_sCountOutputType without action
   */
  export type Account_sCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account_sCountOutputType
     */
    select?: Account_sCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Account_sCountOutputType without action
   */
  export type Account_sCountOutputTypeCountCredit_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_sWhereInput
  }

  /**
   * Account_sCountOutputType without action
   */
  export type Account_sCountOutputTypeCountSale_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sale_sWhereInput
  }


  /**
   * Count Type Client_sCountOutputType
   */

  export type Client_sCountOutputType = {
    credit_s: number
    sale_s: number
  }

  export type Client_sCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | Client_sCountOutputTypeCountCredit_sArgs
    sale_s?: boolean | Client_sCountOutputTypeCountSale_sArgs
  }

  // Custom InputTypes
  /**
   * Client_sCountOutputType without action
   */
  export type Client_sCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client_sCountOutputType
     */
    select?: Client_sCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Client_sCountOutputType without action
   */
  export type Client_sCountOutputTypeCountCredit_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_sWhereInput
  }

  /**
   * Client_sCountOutputType without action
   */
  export type Client_sCountOutputTypeCountSale_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sale_sWhereInput
  }


  /**
   * Count Type Credit_sCountOutputType
   */

  export type Credit_sCountOutputType = {
    payment_s: number
  }

  export type Credit_sCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_s?: boolean | Credit_sCountOutputTypeCountPayment_sArgs
  }

  // Custom InputTypes
  /**
   * Credit_sCountOutputType without action
   */
  export type Credit_sCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit_sCountOutputType
     */
    select?: Credit_sCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Credit_sCountOutputType without action
   */
  export type Credit_sCountOutputTypeCountPayment_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_sWhereInput
  }


  /**
   * Count Type User_sCountOutputType
   */

  export type User_sCountOutputType = {
    account_s: number
  }

  export type User_sCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | User_sCountOutputTypeCountAccount_sArgs
  }

  // Custom InputTypes
  /**
   * User_sCountOutputType without action
   */
  export type User_sCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_sCountOutputType
     */
    select?: User_sCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_sCountOutputType without action
   */
  export type User_sCountOutputTypeCountAccount_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: account_sWhereInput
  }


  /**
   * Models
   */

  /**
   * Model account_s
   */

  export type AggregateAccount_s = {
    _count: Account_sCountAggregateOutputType | null
    _avg: Account_sAvgAggregateOutputType | null
    _sum: Account_sSumAggregateOutputType | null
    _min: Account_sMinAggregateOutputType | null
    _max: Account_sMaxAggregateOutputType | null
  }

  export type Account_sAvgAggregateOutputType = {
    id_account: number | null
    id_user_account: number | null
    general_valance_account: number | null
  }

  export type Account_sSumAggregateOutputType = {
    id_account: number | null
    id_user_account: number | null
    general_valance_account: number | null
  }

  export type Account_sMinAggregateOutputType = {
    id_account: number | null
    id_user_account: number | null
    e_mail: string | null
    password_: string | null
    name_company: string | null
    general_valance_account: number | null
  }

  export type Account_sMaxAggregateOutputType = {
    id_account: number | null
    id_user_account: number | null
    e_mail: string | null
    password_: string | null
    name_company: string | null
    general_valance_account: number | null
  }

  export type Account_sCountAggregateOutputType = {
    id_account: number
    id_user_account: number
    e_mail: number
    password_: number
    name_company: number
    general_valance_account: number
    _all: number
  }


  export type Account_sAvgAggregateInputType = {
    id_account?: true
    id_user_account?: true
    general_valance_account?: true
  }

  export type Account_sSumAggregateInputType = {
    id_account?: true
    id_user_account?: true
    general_valance_account?: true
  }

  export type Account_sMinAggregateInputType = {
    id_account?: true
    id_user_account?: true
    e_mail?: true
    password_?: true
    name_company?: true
    general_valance_account?: true
  }

  export type Account_sMaxAggregateInputType = {
    id_account?: true
    id_user_account?: true
    e_mail?: true
    password_?: true
    name_company?: true
    general_valance_account?: true
  }

  export type Account_sCountAggregateInputType = {
    id_account?: true
    id_user_account?: true
    e_mail?: true
    password_?: true
    name_company?: true
    general_valance_account?: true
    _all?: true
  }

  export type Account_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_s to aggregate.
     */
    where?: account_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_s to fetch.
     */
    orderBy?: account_sOrderByWithRelationInput | account_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_s
    **/
    _count?: true | Account_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_sMaxAggregateInputType
  }

  export type GetAccount_sAggregateType<T extends Account_sAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_s[P]>
      : GetScalarType<T[P], AggregateAccount_s[P]>
  }




  export type account_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: account_sWhereInput
    orderBy?: account_sOrderByWithAggregationInput | account_sOrderByWithAggregationInput[]
    by: Account_sScalarFieldEnum[] | Account_sScalarFieldEnum
    having?: account_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_sCountAggregateInputType | true
    _avg?: Account_sAvgAggregateInputType
    _sum?: Account_sSumAggregateInputType
    _min?: Account_sMinAggregateInputType
    _max?: Account_sMaxAggregateInputType
  }

  export type Account_sGroupByOutputType = {
    id_account: number
    id_user_account: number | null
    e_mail: string | null
    password_: string | null
    name_company: string | null
    general_valance_account: number | null
    _count: Account_sCountAggregateOutputType | null
    _avg: Account_sAvgAggregateOutputType | null
    _sum: Account_sSumAggregateOutputType | null
    _min: Account_sMinAggregateOutputType | null
    _max: Account_sMaxAggregateOutputType | null
  }

  type GetAccount_sGroupByPayload<T extends account_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Account_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_sGroupByOutputType[P]>
            : GetScalarType<T[P], Account_sGroupByOutputType[P]>
        }
      >
    >


  export type account_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_account?: boolean
    id_user_account?: boolean
    e_mail?: boolean
    password_?: boolean
    name_company?: boolean
    general_valance_account?: boolean
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
    credit_s?: boolean | account_s$credit_sArgs<ExtArgs>
    sale_s?: boolean | account_s$sale_sArgs<ExtArgs>
    _count?: boolean | Account_sCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account_s"]>

  export type account_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_account?: boolean
    id_user_account?: boolean
    e_mail?: boolean
    password_?: boolean
    name_company?: boolean
    general_valance_account?: boolean
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
  }, ExtArgs["result"]["account_s"]>

  export type account_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_account?: boolean
    id_user_account?: boolean
    e_mail?: boolean
    password_?: boolean
    name_company?: boolean
    general_valance_account?: boolean
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
  }, ExtArgs["result"]["account_s"]>

  export type account_sSelectScalar = {
    id_account?: boolean
    id_user_account?: boolean
    e_mail?: boolean
    password_?: boolean
    name_company?: boolean
    general_valance_account?: boolean
  }

  export type account_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_account" | "id_user_account" | "e_mail" | "password_" | "name_company" | "general_valance_account", ExtArgs["result"]["account_s"]>
  export type account_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
    credit_s?: boolean | account_s$credit_sArgs<ExtArgs>
    sale_s?: boolean | account_s$sale_sArgs<ExtArgs>
    _count?: boolean | Account_sCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type account_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
  }
  export type account_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_s?: boolean | account_s$user_sArgs<ExtArgs>
  }

  export type $account_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account_s"
    objects: {
      user_s: Prisma.$user_sPayload<ExtArgs> | null
      credit_s: Prisma.$credit_sPayload<ExtArgs>[]
      sale_s: Prisma.$sale_sPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_account: number
      id_user_account: number | null
      e_mail: string | null
      password_: string | null
      name_company: string | null
      general_valance_account: number | null
    }, ExtArgs["result"]["account_s"]>
    composites: {}
  }

  type account_sGetPayload<S extends boolean | null | undefined | account_sDefaultArgs> = $Result.GetResult<Prisma.$account_sPayload, S>

  type account_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<account_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Account_sCountAggregateInputType | true
    }

  export interface account_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_s'], meta: { name: 'account_s' } }
    /**
     * Find zero or one Account_s that matches the filter.
     * @param {account_sFindUniqueArgs} args - Arguments to find a Account_s
     * @example
     * // Get one Account_s
     * const account_s = await prisma.account_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends account_sFindUniqueArgs>(args: SelectSubset<T, account_sFindUniqueArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {account_sFindUniqueOrThrowArgs} args - Arguments to find a Account_s
     * @example
     * // Get one Account_s
     * const account_s = await prisma.account_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends account_sFindUniqueOrThrowArgs>(args: SelectSubset<T, account_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sFindFirstArgs} args - Arguments to find a Account_s
     * @example
     * // Get one Account_s
     * const account_s = await prisma.account_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends account_sFindFirstArgs>(args?: SelectSubset<T, account_sFindFirstArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sFindFirstOrThrowArgs} args - Arguments to find a Account_s
     * @example
     * // Get one Account_s
     * const account_s = await prisma.account_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends account_sFindFirstOrThrowArgs>(args?: SelectSubset<T, account_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Account_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_s
     * const account_s = await prisma.account_s.findMany()
     * 
     * // Get first 10 Account_s
     * const account_s = await prisma.account_s.findMany({ take: 10 })
     * 
     * // Only select the `id_account`
     * const account_sWithId_accountOnly = await prisma.account_s.findMany({ select: { id_account: true } })
     * 
     */
    findMany<T extends account_sFindManyArgs>(args?: SelectSubset<T, account_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account_s.
     * @param {account_sCreateArgs} args - Arguments to create a Account_s.
     * @example
     * // Create one Account_s
     * const Account_s = await prisma.account_s.create({
     *   data: {
     *     // ... data to create a Account_s
     *   }
     * })
     * 
     */
    create<T extends account_sCreateArgs>(args: SelectSubset<T, account_sCreateArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Account_s.
     * @param {account_sCreateManyArgs} args - Arguments to create many Account_s.
     * @example
     * // Create many Account_s
     * const account_s = await prisma.account_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends account_sCreateManyArgs>(args?: SelectSubset<T, account_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Account_s and returns the data saved in the database.
     * @param {account_sCreateManyAndReturnArgs} args - Arguments to create many Account_s.
     * @example
     * // Create many Account_s
     * const account_s = await prisma.account_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Account_s and only return the `id_account`
     * const account_sWithId_accountOnly = await prisma.account_s.createManyAndReturn({
     *   select: { id_account: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends account_sCreateManyAndReturnArgs>(args?: SelectSubset<T, account_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account_s.
     * @param {account_sDeleteArgs} args - Arguments to delete one Account_s.
     * @example
     * // Delete one Account_s
     * const Account_s = await prisma.account_s.delete({
     *   where: {
     *     // ... filter to delete one Account_s
     *   }
     * })
     * 
     */
    delete<T extends account_sDeleteArgs>(args: SelectSubset<T, account_sDeleteArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account_s.
     * @param {account_sUpdateArgs} args - Arguments to update one Account_s.
     * @example
     * // Update one Account_s
     * const account_s = await prisma.account_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends account_sUpdateArgs>(args: SelectSubset<T, account_sUpdateArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Account_s.
     * @param {account_sDeleteManyArgs} args - Arguments to filter Account_s to delete.
     * @example
     * // Delete a few Account_s
     * const { count } = await prisma.account_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends account_sDeleteManyArgs>(args?: SelectSubset<T, account_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_s
     * const account_s = await prisma.account_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends account_sUpdateManyArgs>(args: SelectSubset<T, account_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_s and returns the data updated in the database.
     * @param {account_sUpdateManyAndReturnArgs} args - Arguments to update many Account_s.
     * @example
     * // Update many Account_s
     * const account_s = await prisma.account_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Account_s and only return the `id_account`
     * const account_sWithId_accountOnly = await prisma.account_s.updateManyAndReturn({
     *   select: { id_account: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends account_sUpdateManyAndReturnArgs>(args: SelectSubset<T, account_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account_s.
     * @param {account_sUpsertArgs} args - Arguments to update or create a Account_s.
     * @example
     * // Update or create a Account_s
     * const account_s = await prisma.account_s.upsert({
     *   create: {
     *     // ... data to create a Account_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_s we want to update
     *   }
     * })
     */
    upsert<T extends account_sUpsertArgs>(args: SelectSubset<T, account_sUpsertArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Account_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sCountArgs} args - Arguments to filter Account_s to count.
     * @example
     * // Count the number of Account_s
     * const count = await prisma.account_s.count({
     *   where: {
     *     // ... the filter for the Account_s we want to count
     *   }
     * })
    **/
    count<T extends account_sCountArgs>(
      args?: Subset<T, account_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_sAggregateArgs>(args: Subset<T, Account_sAggregateArgs>): Prisma.PrismaPromise<GetAccount_sAggregateType<T>>

    /**
     * Group by Account_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends account_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: account_sGroupByArgs['orderBy'] }
        : { orderBy?: account_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, account_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account_s model
   */
  readonly fields: account_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__account_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_s<T extends account_s$user_sArgs<ExtArgs> = {}>(args?: Subset<T, account_s$user_sArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    credit_s<T extends account_s$credit_sArgs<ExtArgs> = {}>(args?: Subset<T, account_s$credit_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sale_s<T extends account_s$sale_sArgs<ExtArgs> = {}>(args?: Subset<T, account_s$sale_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the account_s model
   */
  interface account_sFieldRefs {
    readonly id_account: FieldRef<"account_s", 'Int'>
    readonly id_user_account: FieldRef<"account_s", 'Int'>
    readonly e_mail: FieldRef<"account_s", 'String'>
    readonly password_: FieldRef<"account_s", 'String'>
    readonly name_company: FieldRef<"account_s", 'String'>
    readonly general_valance_account: FieldRef<"account_s", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * account_s findUnique
   */
  export type account_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter, which account_s to fetch.
     */
    where: account_sWhereUniqueInput
  }

  /**
   * account_s findUniqueOrThrow
   */
  export type account_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter, which account_s to fetch.
     */
    where: account_sWhereUniqueInput
  }

  /**
   * account_s findFirst
   */
  export type account_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter, which account_s to fetch.
     */
    where?: account_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_s to fetch.
     */
    orderBy?: account_sOrderByWithRelationInput | account_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_s.
     */
    cursor?: account_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_s.
     */
    distinct?: Account_sScalarFieldEnum | Account_sScalarFieldEnum[]
  }

  /**
   * account_s findFirstOrThrow
   */
  export type account_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter, which account_s to fetch.
     */
    where?: account_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_s to fetch.
     */
    orderBy?: account_sOrderByWithRelationInput | account_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_s.
     */
    cursor?: account_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_s.
     */
    distinct?: Account_sScalarFieldEnum | Account_sScalarFieldEnum[]
  }

  /**
   * account_s findMany
   */
  export type account_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter, which account_s to fetch.
     */
    where?: account_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_s to fetch.
     */
    orderBy?: account_sOrderByWithRelationInput | account_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_s.
     */
    cursor?: account_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_s.
     */
    skip?: number
    distinct?: Account_sScalarFieldEnum | Account_sScalarFieldEnum[]
  }

  /**
   * account_s create
   */
  export type account_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * The data needed to create a account_s.
     */
    data: XOR<account_sCreateInput, account_sUncheckedCreateInput>
  }

  /**
   * account_s createMany
   */
  export type account_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_s.
     */
    data: account_sCreateManyInput | account_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * account_s createManyAndReturn
   */
  export type account_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * The data used to create many account_s.
     */
    data: account_sCreateManyInput | account_sCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * account_s update
   */
  export type account_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * The data needed to update a account_s.
     */
    data: XOR<account_sUpdateInput, account_sUncheckedUpdateInput>
    /**
     * Choose, which account_s to update.
     */
    where: account_sWhereUniqueInput
  }

  /**
   * account_s updateMany
   */
  export type account_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_s.
     */
    data: XOR<account_sUpdateManyMutationInput, account_sUncheckedUpdateManyInput>
    /**
     * Filter which account_s to update
     */
    where?: account_sWhereInput
    /**
     * Limit how many account_s to update.
     */
    limit?: number
  }

  /**
   * account_s updateManyAndReturn
   */
  export type account_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * The data used to update account_s.
     */
    data: XOR<account_sUpdateManyMutationInput, account_sUncheckedUpdateManyInput>
    /**
     * Filter which account_s to update
     */
    where?: account_sWhereInput
    /**
     * Limit how many account_s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * account_s upsert
   */
  export type account_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * The filter to search for the account_s to update in case it exists.
     */
    where: account_sWhereUniqueInput
    /**
     * In case the account_s found by the `where` argument doesn't exist, create a new account_s with this data.
     */
    create: XOR<account_sCreateInput, account_sUncheckedCreateInput>
    /**
     * In case the account_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_sUpdateInput, account_sUncheckedUpdateInput>
  }

  /**
   * account_s delete
   */
  export type account_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    /**
     * Filter which account_s to delete.
     */
    where: account_sWhereUniqueInput
  }

  /**
   * account_s deleteMany
   */
  export type account_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_s to delete
     */
    where?: account_sWhereInput
    /**
     * Limit how many account_s to delete.
     */
    limit?: number
  }

  /**
   * account_s.user_s
   */
  export type account_s$user_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    where?: user_sWhereInput
  }

  /**
   * account_s.credit_s
   */
  export type account_s$credit_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    where?: credit_sWhereInput
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    cursor?: credit_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Credit_sScalarFieldEnum | Credit_sScalarFieldEnum[]
  }

  /**
   * account_s.sale_s
   */
  export type account_s$sale_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    where?: sale_sWhereInput
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    cursor?: sale_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sale_sScalarFieldEnum | Sale_sScalarFieldEnum[]
  }

  /**
   * account_s without action
   */
  export type account_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
  }


  /**
   * Model client_s
   */

  export type AggregateClient_s = {
    _count: Client_sCountAggregateOutputType | null
    _avg: Client_sAvgAggregateOutputType | null
    _sum: Client_sSumAggregateOutputType | null
    _min: Client_sMinAggregateOutputType | null
    _max: Client_sMaxAggregateOutputType | null
  }

  export type Client_sAvgAggregateOutputType = {
    id_client: number | null
    id_account_client: number | null
    valance_credit_client: number | null
  }

  export type Client_sSumAggregateOutputType = {
    id_client: number | null
    id_account_client: number | null
    valance_credit_client: number | null
  }

  export type Client_sMinAggregateOutputType = {
    id_client: number | null
    id_account_client: number | null
    address_client: string | null
    name_client: string | null
    valance_credit_client: number | null
  }

  export type Client_sMaxAggregateOutputType = {
    id_client: number | null
    id_account_client: number | null
    address_client: string | null
    name_client: string | null
    valance_credit_client: number | null
  }

  export type Client_sCountAggregateOutputType = {
    id_client: number
    id_account_client: number
    address_client: number
    name_client: number
    valance_credit_client: number
    _all: number
  }


  export type Client_sAvgAggregateInputType = {
    id_client?: true
    id_account_client?: true
    valance_credit_client?: true
  }

  export type Client_sSumAggregateInputType = {
    id_client?: true
    id_account_client?: true
    valance_credit_client?: true
  }

  export type Client_sMinAggregateInputType = {
    id_client?: true
    id_account_client?: true
    address_client?: true
    name_client?: true
    valance_credit_client?: true
  }

  export type Client_sMaxAggregateInputType = {
    id_client?: true
    id_account_client?: true
    address_client?: true
    name_client?: true
    valance_credit_client?: true
  }

  export type Client_sCountAggregateInputType = {
    id_client?: true
    id_account_client?: true
    address_client?: true
    name_client?: true
    valance_credit_client?: true
    _all?: true
  }

  export type Client_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_s to aggregate.
     */
    where?: client_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_s to fetch.
     */
    orderBy?: client_sOrderByWithRelationInput | client_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_s
    **/
    _count?: true | Client_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Client_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Client_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_sMaxAggregateInputType
  }

  export type GetClient_sAggregateType<T extends Client_sAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_s[P]>
      : GetScalarType<T[P], AggregateClient_s[P]>
  }




  export type client_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_sWhereInput
    orderBy?: client_sOrderByWithAggregationInput | client_sOrderByWithAggregationInput[]
    by: Client_sScalarFieldEnum[] | Client_sScalarFieldEnum
    having?: client_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_sCountAggregateInputType | true
    _avg?: Client_sAvgAggregateInputType
    _sum?: Client_sSumAggregateInputType
    _min?: Client_sMinAggregateInputType
    _max?: Client_sMaxAggregateInputType
  }

  export type Client_sGroupByOutputType = {
    id_client: number
    id_account_client: number | null
    address_client: string | null
    name_client: string | null
    valance_credit_client: number | null
    _count: Client_sCountAggregateOutputType | null
    _avg: Client_sAvgAggregateOutputType | null
    _sum: Client_sSumAggregateOutputType | null
    _min: Client_sMinAggregateOutputType | null
    _max: Client_sMaxAggregateOutputType | null
  }

  type GetClient_sGroupByPayload<T extends client_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_sGroupByOutputType[P]>
            : GetScalarType<T[P], Client_sGroupByOutputType[P]>
        }
      >
    >


  export type client_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_client?: boolean
    id_account_client?: boolean
    address_client?: boolean
    name_client?: boolean
    valance_credit_client?: boolean
    credit_s?: boolean | client_s$credit_sArgs<ExtArgs>
    sale_s?: boolean | client_s$sale_sArgs<ExtArgs>
    _count?: boolean | Client_sCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client_s"]>

  export type client_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_client?: boolean
    id_account_client?: boolean
    address_client?: boolean
    name_client?: boolean
    valance_credit_client?: boolean
  }, ExtArgs["result"]["client_s"]>

  export type client_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_client?: boolean
    id_account_client?: boolean
    address_client?: boolean
    name_client?: boolean
    valance_credit_client?: boolean
  }, ExtArgs["result"]["client_s"]>

  export type client_sSelectScalar = {
    id_client?: boolean
    id_account_client?: boolean
    address_client?: boolean
    name_client?: boolean
    valance_credit_client?: boolean
  }

  export type client_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_client" | "id_account_client" | "address_client" | "name_client" | "valance_credit_client", ExtArgs["result"]["client_s"]>
  export type client_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | client_s$credit_sArgs<ExtArgs>
    sale_s?: boolean | client_s$sale_sArgs<ExtArgs>
    _count?: boolean | Client_sCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type client_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type client_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $client_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client_s"
    objects: {
      credit_s: Prisma.$credit_sPayload<ExtArgs>[]
      sale_s: Prisma.$sale_sPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_client: number
      id_account_client: number | null
      address_client: string | null
      name_client: string | null
      valance_credit_client: number | null
    }, ExtArgs["result"]["client_s"]>
    composites: {}
  }

  type client_sGetPayload<S extends boolean | null | undefined | client_sDefaultArgs> = $Result.GetResult<Prisma.$client_sPayload, S>

  type client_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<client_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Client_sCountAggregateInputType | true
    }

  export interface client_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_s'], meta: { name: 'client_s' } }
    /**
     * Find zero or one Client_s that matches the filter.
     * @param {client_sFindUniqueArgs} args - Arguments to find a Client_s
     * @example
     * // Get one Client_s
     * const client_s = await prisma.client_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends client_sFindUniqueArgs>(args: SelectSubset<T, client_sFindUniqueArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {client_sFindUniqueOrThrowArgs} args - Arguments to find a Client_s
     * @example
     * // Get one Client_s
     * const client_s = await prisma.client_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends client_sFindUniqueOrThrowArgs>(args: SelectSubset<T, client_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sFindFirstArgs} args - Arguments to find a Client_s
     * @example
     * // Get one Client_s
     * const client_s = await prisma.client_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends client_sFindFirstArgs>(args?: SelectSubset<T, client_sFindFirstArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sFindFirstOrThrowArgs} args - Arguments to find a Client_s
     * @example
     * // Get one Client_s
     * const client_s = await prisma.client_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends client_sFindFirstOrThrowArgs>(args?: SelectSubset<T, client_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Client_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_s
     * const client_s = await prisma.client_s.findMany()
     * 
     * // Get first 10 Client_s
     * const client_s = await prisma.client_s.findMany({ take: 10 })
     * 
     * // Only select the `id_client`
     * const client_sWithId_clientOnly = await prisma.client_s.findMany({ select: { id_client: true } })
     * 
     */
    findMany<T extends client_sFindManyArgs>(args?: SelectSubset<T, client_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client_s.
     * @param {client_sCreateArgs} args - Arguments to create a Client_s.
     * @example
     * // Create one Client_s
     * const Client_s = await prisma.client_s.create({
     *   data: {
     *     // ... data to create a Client_s
     *   }
     * })
     * 
     */
    create<T extends client_sCreateArgs>(args: SelectSubset<T, client_sCreateArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Client_s.
     * @param {client_sCreateManyArgs} args - Arguments to create many Client_s.
     * @example
     * // Create many Client_s
     * const client_s = await prisma.client_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends client_sCreateManyArgs>(args?: SelectSubset<T, client_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Client_s and returns the data saved in the database.
     * @param {client_sCreateManyAndReturnArgs} args - Arguments to create many Client_s.
     * @example
     * // Create many Client_s
     * const client_s = await prisma.client_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Client_s and only return the `id_client`
     * const client_sWithId_clientOnly = await prisma.client_s.createManyAndReturn({
     *   select: { id_client: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends client_sCreateManyAndReturnArgs>(args?: SelectSubset<T, client_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client_s.
     * @param {client_sDeleteArgs} args - Arguments to delete one Client_s.
     * @example
     * // Delete one Client_s
     * const Client_s = await prisma.client_s.delete({
     *   where: {
     *     // ... filter to delete one Client_s
     *   }
     * })
     * 
     */
    delete<T extends client_sDeleteArgs>(args: SelectSubset<T, client_sDeleteArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client_s.
     * @param {client_sUpdateArgs} args - Arguments to update one Client_s.
     * @example
     * // Update one Client_s
     * const client_s = await prisma.client_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends client_sUpdateArgs>(args: SelectSubset<T, client_sUpdateArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Client_s.
     * @param {client_sDeleteManyArgs} args - Arguments to filter Client_s to delete.
     * @example
     * // Delete a few Client_s
     * const { count } = await prisma.client_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends client_sDeleteManyArgs>(args?: SelectSubset<T, client_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_s
     * const client_s = await prisma.client_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends client_sUpdateManyArgs>(args: SelectSubset<T, client_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_s and returns the data updated in the database.
     * @param {client_sUpdateManyAndReturnArgs} args - Arguments to update many Client_s.
     * @example
     * // Update many Client_s
     * const client_s = await prisma.client_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Client_s and only return the `id_client`
     * const client_sWithId_clientOnly = await prisma.client_s.updateManyAndReturn({
     *   select: { id_client: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends client_sUpdateManyAndReturnArgs>(args: SelectSubset<T, client_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client_s.
     * @param {client_sUpsertArgs} args - Arguments to update or create a Client_s.
     * @example
     * // Update or create a Client_s
     * const client_s = await prisma.client_s.upsert({
     *   create: {
     *     // ... data to create a Client_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_s we want to update
     *   }
     * })
     */
    upsert<T extends client_sUpsertArgs>(args: SelectSubset<T, client_sUpsertArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Client_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sCountArgs} args - Arguments to filter Client_s to count.
     * @example
     * // Count the number of Client_s
     * const count = await prisma.client_s.count({
     *   where: {
     *     // ... the filter for the Client_s we want to count
     *   }
     * })
    **/
    count<T extends client_sCountArgs>(
      args?: Subset<T, client_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_sAggregateArgs>(args: Subset<T, Client_sAggregateArgs>): Prisma.PrismaPromise<GetClient_sAggregateType<T>>

    /**
     * Group by Client_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_sGroupByArgs['orderBy'] }
        : { orderBy?: client_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_s model
   */
  readonly fields: client_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__client_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_s<T extends client_s$credit_sArgs<ExtArgs> = {}>(args?: Subset<T, client_s$credit_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sale_s<T extends client_s$sale_sArgs<ExtArgs> = {}>(args?: Subset<T, client_s$sale_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client_s model
   */
  interface client_sFieldRefs {
    readonly id_client: FieldRef<"client_s", 'Int'>
    readonly id_account_client: FieldRef<"client_s", 'Int'>
    readonly address_client: FieldRef<"client_s", 'String'>
    readonly name_client: FieldRef<"client_s", 'String'>
    readonly valance_credit_client: FieldRef<"client_s", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * client_s findUnique
   */
  export type client_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter, which client_s to fetch.
     */
    where: client_sWhereUniqueInput
  }

  /**
   * client_s findUniqueOrThrow
   */
  export type client_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter, which client_s to fetch.
     */
    where: client_sWhereUniqueInput
  }

  /**
   * client_s findFirst
   */
  export type client_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter, which client_s to fetch.
     */
    where?: client_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_s to fetch.
     */
    orderBy?: client_sOrderByWithRelationInput | client_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_s.
     */
    cursor?: client_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_s.
     */
    distinct?: Client_sScalarFieldEnum | Client_sScalarFieldEnum[]
  }

  /**
   * client_s findFirstOrThrow
   */
  export type client_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter, which client_s to fetch.
     */
    where?: client_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_s to fetch.
     */
    orderBy?: client_sOrderByWithRelationInput | client_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_s.
     */
    cursor?: client_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_s.
     */
    distinct?: Client_sScalarFieldEnum | Client_sScalarFieldEnum[]
  }

  /**
   * client_s findMany
   */
  export type client_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter, which client_s to fetch.
     */
    where?: client_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_s to fetch.
     */
    orderBy?: client_sOrderByWithRelationInput | client_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_s.
     */
    cursor?: client_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_s.
     */
    skip?: number
    distinct?: Client_sScalarFieldEnum | Client_sScalarFieldEnum[]
  }

  /**
   * client_s create
   */
  export type client_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * The data needed to create a client_s.
     */
    data: XOR<client_sCreateInput, client_sUncheckedCreateInput>
  }

  /**
   * client_s createMany
   */
  export type client_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_s.
     */
    data: client_sCreateManyInput | client_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_s createManyAndReturn
   */
  export type client_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * The data used to create many client_s.
     */
    data: client_sCreateManyInput | client_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_s update
   */
  export type client_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * The data needed to update a client_s.
     */
    data: XOR<client_sUpdateInput, client_sUncheckedUpdateInput>
    /**
     * Choose, which client_s to update.
     */
    where: client_sWhereUniqueInput
  }

  /**
   * client_s updateMany
   */
  export type client_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_s.
     */
    data: XOR<client_sUpdateManyMutationInput, client_sUncheckedUpdateManyInput>
    /**
     * Filter which client_s to update
     */
    where?: client_sWhereInput
    /**
     * Limit how many client_s to update.
     */
    limit?: number
  }

  /**
   * client_s updateManyAndReturn
   */
  export type client_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * The data used to update client_s.
     */
    data: XOR<client_sUpdateManyMutationInput, client_sUncheckedUpdateManyInput>
    /**
     * Filter which client_s to update
     */
    where?: client_sWhereInput
    /**
     * Limit how many client_s to update.
     */
    limit?: number
  }

  /**
   * client_s upsert
   */
  export type client_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * The filter to search for the client_s to update in case it exists.
     */
    where: client_sWhereUniqueInput
    /**
     * In case the client_s found by the `where` argument doesn't exist, create a new client_s with this data.
     */
    create: XOR<client_sCreateInput, client_sUncheckedCreateInput>
    /**
     * In case the client_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_sUpdateInput, client_sUncheckedUpdateInput>
  }

  /**
   * client_s delete
   */
  export type client_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    /**
     * Filter which client_s to delete.
     */
    where: client_sWhereUniqueInput
  }

  /**
   * client_s deleteMany
   */
  export type client_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_s to delete
     */
    where?: client_sWhereInput
    /**
     * Limit how many client_s to delete.
     */
    limit?: number
  }

  /**
   * client_s.credit_s
   */
  export type client_s$credit_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    where?: credit_sWhereInput
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    cursor?: credit_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Credit_sScalarFieldEnum | Credit_sScalarFieldEnum[]
  }

  /**
   * client_s.sale_s
   */
  export type client_s$sale_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    where?: sale_sWhereInput
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    cursor?: sale_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sale_sScalarFieldEnum | Sale_sScalarFieldEnum[]
  }

  /**
   * client_s without action
   */
  export type client_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
  }


  /**
   * Model credit_s
   */

  export type AggregateCredit_s = {
    _count: Credit_sCountAggregateOutputType | null
    _avg: Credit_sAvgAggregateOutputType | null
    _sum: Credit_sSumAggregateOutputType | null
    _min: Credit_sMinAggregateOutputType | null
    _max: Credit_sMaxAggregateOutputType | null
  }

  export type Credit_sAvgAggregateOutputType = {
    id_credit: number | null
    id_account_credit: number | null
    id_client_credit: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    total_payment_acumulation: number | null
  }

  export type Credit_sSumAggregateOutputType = {
    id_credit: number | null
    id_account_credit: number | null
    id_client_credit: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    total_payment_acumulation: number | null
  }

  export type Credit_sMinAggregateOutputType = {
    id_credit: number | null
    id_account_credit: number | null
    id_client_credit: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
    total_payment_acumulation: number | null
    credit_state: string | null
  }

  export type Credit_sMaxAggregateOutputType = {
    id_credit: number | null
    id_account_credit: number | null
    id_client_credit: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
    total_payment_acumulation: number | null
    credit_state: string | null
  }

  export type Credit_sCountAggregateOutputType = {
    id_credit: number
    id_account_credit: number
    id_client_credit: number
    price_to_sale: number
    price_to_real_product: number
    product_name: number
    total_payment_acumulation: number
    credit_state: number
    _all: number
  }


  export type Credit_sAvgAggregateInputType = {
    id_credit?: true
    id_account_credit?: true
    id_client_credit?: true
    price_to_sale?: true
    price_to_real_product?: true
    total_payment_acumulation?: true
  }

  export type Credit_sSumAggregateInputType = {
    id_credit?: true
    id_account_credit?: true
    id_client_credit?: true
    price_to_sale?: true
    price_to_real_product?: true
    total_payment_acumulation?: true
  }

  export type Credit_sMinAggregateInputType = {
    id_credit?: true
    id_account_credit?: true
    id_client_credit?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
    total_payment_acumulation?: true
    credit_state?: true
  }

  export type Credit_sMaxAggregateInputType = {
    id_credit?: true
    id_account_credit?: true
    id_client_credit?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
    total_payment_acumulation?: true
    credit_state?: true
  }

  export type Credit_sCountAggregateInputType = {
    id_credit?: true
    id_account_credit?: true
    id_client_credit?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
    total_payment_acumulation?: true
    credit_state?: true
    _all?: true
  }

  export type Credit_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_s to aggregate.
     */
    where?: credit_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_s to fetch.
     */
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credit_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credit_s
    **/
    _count?: true | Credit_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credit_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credit_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credit_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credit_sMaxAggregateInputType
  }

  export type GetCredit_sAggregateType<T extends Credit_sAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit_s[P]>
      : GetScalarType<T[P], AggregateCredit_s[P]>
  }




  export type credit_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_sWhereInput
    orderBy?: credit_sOrderByWithAggregationInput | credit_sOrderByWithAggregationInput[]
    by: Credit_sScalarFieldEnum[] | Credit_sScalarFieldEnum
    having?: credit_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credit_sCountAggregateInputType | true
    _avg?: Credit_sAvgAggregateInputType
    _sum?: Credit_sSumAggregateInputType
    _min?: Credit_sMinAggregateInputType
    _max?: Credit_sMaxAggregateInputType
  }

  export type Credit_sGroupByOutputType = {
    id_credit: number
    id_account_credit: number | null
    id_client_credit: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
    total_payment_acumulation: number | null
    credit_state: string | null
    _count: Credit_sCountAggregateOutputType | null
    _avg: Credit_sAvgAggregateOutputType | null
    _sum: Credit_sSumAggregateOutputType | null
    _min: Credit_sMinAggregateOutputType | null
    _max: Credit_sMaxAggregateOutputType | null
  }

  type GetCredit_sGroupByPayload<T extends credit_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credit_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credit_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credit_sGroupByOutputType[P]>
            : GetScalarType<T[P], Credit_sGroupByOutputType[P]>
        }
      >
    >


  export type credit_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_credit?: boolean
    id_account_credit?: boolean
    id_client_credit?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    total_payment_acumulation?: boolean
    credit_state?: boolean
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
    payment_s?: boolean | credit_s$payment_sArgs<ExtArgs>
    _count?: boolean | Credit_sCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit_s"]>

  export type credit_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_credit?: boolean
    id_account_credit?: boolean
    id_client_credit?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    total_payment_acumulation?: boolean
    credit_state?: boolean
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
  }, ExtArgs["result"]["credit_s"]>

  export type credit_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_credit?: boolean
    id_account_credit?: boolean
    id_client_credit?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    total_payment_acumulation?: boolean
    credit_state?: boolean
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
  }, ExtArgs["result"]["credit_s"]>

  export type credit_sSelectScalar = {
    id_credit?: boolean
    id_account_credit?: boolean
    id_client_credit?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    total_payment_acumulation?: boolean
    credit_state?: boolean
  }

  export type credit_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_credit" | "id_account_credit" | "id_client_credit" | "price_to_sale" | "price_to_real_product" | "product_name" | "total_payment_acumulation" | "credit_state", ExtArgs["result"]["credit_s"]>
  export type credit_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
    payment_s?: boolean | credit_s$payment_sArgs<ExtArgs>
    _count?: boolean | Credit_sCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type credit_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
  }
  export type credit_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | credit_s$account_sArgs<ExtArgs>
    client_s?: boolean | credit_s$client_sArgs<ExtArgs>
  }

  export type $credit_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credit_s"
    objects: {
      account_s: Prisma.$account_sPayload<ExtArgs> | null
      client_s: Prisma.$client_sPayload<ExtArgs> | null
      payment_s: Prisma.$payment_sPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_credit: number
      id_account_credit: number | null
      id_client_credit: number | null
      price_to_sale: number | null
      price_to_real_product: number | null
      product_name: string | null
      total_payment_acumulation: number | null
      credit_state: string | null
    }, ExtArgs["result"]["credit_s"]>
    composites: {}
  }

  type credit_sGetPayload<S extends boolean | null | undefined | credit_sDefaultArgs> = $Result.GetResult<Prisma.$credit_sPayload, S>

  type credit_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<credit_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Credit_sCountAggregateInputType | true
    }

  export interface credit_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credit_s'], meta: { name: 'credit_s' } }
    /**
     * Find zero or one Credit_s that matches the filter.
     * @param {credit_sFindUniqueArgs} args - Arguments to find a Credit_s
     * @example
     * // Get one Credit_s
     * const credit_s = await prisma.credit_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credit_sFindUniqueArgs>(args: SelectSubset<T, credit_sFindUniqueArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credit_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {credit_sFindUniqueOrThrowArgs} args - Arguments to find a Credit_s
     * @example
     * // Get one Credit_s
     * const credit_s = await prisma.credit_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credit_sFindUniqueOrThrowArgs>(args: SelectSubset<T, credit_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sFindFirstArgs} args - Arguments to find a Credit_s
     * @example
     * // Get one Credit_s
     * const credit_s = await prisma.credit_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credit_sFindFirstArgs>(args?: SelectSubset<T, credit_sFindFirstArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sFindFirstOrThrowArgs} args - Arguments to find a Credit_s
     * @example
     * // Get one Credit_s
     * const credit_s = await prisma.credit_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credit_sFindFirstOrThrowArgs>(args?: SelectSubset<T, credit_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credit_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credit_s
     * const credit_s = await prisma.credit_s.findMany()
     * 
     * // Get first 10 Credit_s
     * const credit_s = await prisma.credit_s.findMany({ take: 10 })
     * 
     * // Only select the `id_credit`
     * const credit_sWithId_creditOnly = await prisma.credit_s.findMany({ select: { id_credit: true } })
     * 
     */
    findMany<T extends credit_sFindManyArgs>(args?: SelectSubset<T, credit_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credit_s.
     * @param {credit_sCreateArgs} args - Arguments to create a Credit_s.
     * @example
     * // Create one Credit_s
     * const Credit_s = await prisma.credit_s.create({
     *   data: {
     *     // ... data to create a Credit_s
     *   }
     * })
     * 
     */
    create<T extends credit_sCreateArgs>(args: SelectSubset<T, credit_sCreateArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credit_s.
     * @param {credit_sCreateManyArgs} args - Arguments to create many Credit_s.
     * @example
     * // Create many Credit_s
     * const credit_s = await prisma.credit_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credit_sCreateManyArgs>(args?: SelectSubset<T, credit_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credit_s and returns the data saved in the database.
     * @param {credit_sCreateManyAndReturnArgs} args - Arguments to create many Credit_s.
     * @example
     * // Create many Credit_s
     * const credit_s = await prisma.credit_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credit_s and only return the `id_credit`
     * const credit_sWithId_creditOnly = await prisma.credit_s.createManyAndReturn({
     *   select: { id_credit: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credit_sCreateManyAndReturnArgs>(args?: SelectSubset<T, credit_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credit_s.
     * @param {credit_sDeleteArgs} args - Arguments to delete one Credit_s.
     * @example
     * // Delete one Credit_s
     * const Credit_s = await prisma.credit_s.delete({
     *   where: {
     *     // ... filter to delete one Credit_s
     *   }
     * })
     * 
     */
    delete<T extends credit_sDeleteArgs>(args: SelectSubset<T, credit_sDeleteArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credit_s.
     * @param {credit_sUpdateArgs} args - Arguments to update one Credit_s.
     * @example
     * // Update one Credit_s
     * const credit_s = await prisma.credit_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credit_sUpdateArgs>(args: SelectSubset<T, credit_sUpdateArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credit_s.
     * @param {credit_sDeleteManyArgs} args - Arguments to filter Credit_s to delete.
     * @example
     * // Delete a few Credit_s
     * const { count } = await prisma.credit_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credit_sDeleteManyArgs>(args?: SelectSubset<T, credit_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credit_s
     * const credit_s = await prisma.credit_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credit_sUpdateManyArgs>(args: SelectSubset<T, credit_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_s and returns the data updated in the database.
     * @param {credit_sUpdateManyAndReturnArgs} args - Arguments to update many Credit_s.
     * @example
     * // Update many Credit_s
     * const credit_s = await prisma.credit_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credit_s and only return the `id_credit`
     * const credit_sWithId_creditOnly = await prisma.credit_s.updateManyAndReturn({
     *   select: { id_credit: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends credit_sUpdateManyAndReturnArgs>(args: SelectSubset<T, credit_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credit_s.
     * @param {credit_sUpsertArgs} args - Arguments to update or create a Credit_s.
     * @example
     * // Update or create a Credit_s
     * const credit_s = await prisma.credit_s.upsert({
     *   create: {
     *     // ... data to create a Credit_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit_s we want to update
     *   }
     * })
     */
    upsert<T extends credit_sUpsertArgs>(args: SelectSubset<T, credit_sUpsertArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credit_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sCountArgs} args - Arguments to filter Credit_s to count.
     * @example
     * // Count the number of Credit_s
     * const count = await prisma.credit_s.count({
     *   where: {
     *     // ... the filter for the Credit_s we want to count
     *   }
     * })
    **/
    count<T extends credit_sCountArgs>(
      args?: Subset<T, credit_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credit_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credit_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credit_sAggregateArgs>(args: Subset<T, Credit_sAggregateArgs>): Prisma.PrismaPromise<GetCredit_sAggregateType<T>>

    /**
     * Group by Credit_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credit_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credit_sGroupByArgs['orderBy'] }
        : { orderBy?: credit_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credit_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredit_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credit_s model
   */
  readonly fields: credit_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credit_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credit_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_s<T extends credit_s$account_sArgs<ExtArgs> = {}>(args?: Subset<T, credit_s$account_sArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client_s<T extends credit_s$client_sArgs<ExtArgs> = {}>(args?: Subset<T, credit_s$client_sArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment_s<T extends credit_s$payment_sArgs<ExtArgs> = {}>(args?: Subset<T, credit_s$payment_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credit_s model
   */
  interface credit_sFieldRefs {
    readonly id_credit: FieldRef<"credit_s", 'Int'>
    readonly id_account_credit: FieldRef<"credit_s", 'Int'>
    readonly id_client_credit: FieldRef<"credit_s", 'Int'>
    readonly price_to_sale: FieldRef<"credit_s", 'Float'>
    readonly price_to_real_product: FieldRef<"credit_s", 'Float'>
    readonly product_name: FieldRef<"credit_s", 'String'>
    readonly total_payment_acumulation: FieldRef<"credit_s", 'Float'>
    readonly credit_state: FieldRef<"credit_s", 'String'>
  }
    

  // Custom InputTypes
  /**
   * credit_s findUnique
   */
  export type credit_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter, which credit_s to fetch.
     */
    where: credit_sWhereUniqueInput
  }

  /**
   * credit_s findUniqueOrThrow
   */
  export type credit_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter, which credit_s to fetch.
     */
    where: credit_sWhereUniqueInput
  }

  /**
   * credit_s findFirst
   */
  export type credit_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter, which credit_s to fetch.
     */
    where?: credit_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_s to fetch.
     */
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_s.
     */
    cursor?: credit_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_s.
     */
    distinct?: Credit_sScalarFieldEnum | Credit_sScalarFieldEnum[]
  }

  /**
   * credit_s findFirstOrThrow
   */
  export type credit_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter, which credit_s to fetch.
     */
    where?: credit_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_s to fetch.
     */
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_s.
     */
    cursor?: credit_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_s.
     */
    distinct?: Credit_sScalarFieldEnum | Credit_sScalarFieldEnum[]
  }

  /**
   * credit_s findMany
   */
  export type credit_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter, which credit_s to fetch.
     */
    where?: credit_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_s to fetch.
     */
    orderBy?: credit_sOrderByWithRelationInput | credit_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credit_s.
     */
    cursor?: credit_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_s.
     */
    skip?: number
    distinct?: Credit_sScalarFieldEnum | Credit_sScalarFieldEnum[]
  }

  /**
   * credit_s create
   */
  export type credit_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * The data needed to create a credit_s.
     */
    data: XOR<credit_sCreateInput, credit_sUncheckedCreateInput>
  }

  /**
   * credit_s createMany
   */
  export type credit_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credit_s.
     */
    data: credit_sCreateManyInput | credit_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_s createManyAndReturn
   */
  export type credit_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * The data used to create many credit_s.
     */
    data: credit_sCreateManyInput | credit_sCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * credit_s update
   */
  export type credit_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * The data needed to update a credit_s.
     */
    data: XOR<credit_sUpdateInput, credit_sUncheckedUpdateInput>
    /**
     * Choose, which credit_s to update.
     */
    where: credit_sWhereUniqueInput
  }

  /**
   * credit_s updateMany
   */
  export type credit_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credit_s.
     */
    data: XOR<credit_sUpdateManyMutationInput, credit_sUncheckedUpdateManyInput>
    /**
     * Filter which credit_s to update
     */
    where?: credit_sWhereInput
    /**
     * Limit how many credit_s to update.
     */
    limit?: number
  }

  /**
   * credit_s updateManyAndReturn
   */
  export type credit_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * The data used to update credit_s.
     */
    data: XOR<credit_sUpdateManyMutationInput, credit_sUncheckedUpdateManyInput>
    /**
     * Filter which credit_s to update
     */
    where?: credit_sWhereInput
    /**
     * Limit how many credit_s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * credit_s upsert
   */
  export type credit_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * The filter to search for the credit_s to update in case it exists.
     */
    where: credit_sWhereUniqueInput
    /**
     * In case the credit_s found by the `where` argument doesn't exist, create a new credit_s with this data.
     */
    create: XOR<credit_sCreateInput, credit_sUncheckedCreateInput>
    /**
     * In case the credit_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credit_sUpdateInput, credit_sUncheckedUpdateInput>
  }

  /**
   * credit_s delete
   */
  export type credit_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    /**
     * Filter which credit_s to delete.
     */
    where: credit_sWhereUniqueInput
  }

  /**
   * credit_s deleteMany
   */
  export type credit_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_s to delete
     */
    where?: credit_sWhereInput
    /**
     * Limit how many credit_s to delete.
     */
    limit?: number
  }

  /**
   * credit_s.account_s
   */
  export type credit_s$account_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    where?: account_sWhereInput
  }

  /**
   * credit_s.client_s
   */
  export type credit_s$client_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    where?: client_sWhereInput
  }

  /**
   * credit_s.payment_s
   */
  export type credit_s$payment_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    where?: payment_sWhereInput
    orderBy?: payment_sOrderByWithRelationInput | payment_sOrderByWithRelationInput[]
    cursor?: payment_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_sScalarFieldEnum | Payment_sScalarFieldEnum[]
  }

  /**
   * credit_s without action
   */
  export type credit_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
  }


  /**
   * Model payment_s
   */

  export type AggregatePayment_s = {
    _count: Payment_sCountAggregateOutputType | null
    _avg: Payment_sAvgAggregateOutputType | null
    _sum: Payment_sSumAggregateOutputType | null
    _min: Payment_sMinAggregateOutputType | null
    _max: Payment_sMaxAggregateOutputType | null
  }

  export type Payment_sAvgAggregateOutputType = {
    id_payment: number | null
    id_credit_payment: number | null
    payment: number | null
  }

  export type Payment_sSumAggregateOutputType = {
    id_payment: number | null
    id_credit_payment: number | null
    payment: number | null
  }

  export type Payment_sMinAggregateOutputType = {
    id_payment: number | null
    id_credit_payment: number | null
    payment: number | null
  }

  export type Payment_sMaxAggregateOutputType = {
    id_payment: number | null
    id_credit_payment: number | null
    payment: number | null
  }

  export type Payment_sCountAggregateOutputType = {
    id_payment: number
    id_credit_payment: number
    payment: number
    _all: number
  }


  export type Payment_sAvgAggregateInputType = {
    id_payment?: true
    id_credit_payment?: true
    payment?: true
  }

  export type Payment_sSumAggregateInputType = {
    id_payment?: true
    id_credit_payment?: true
    payment?: true
  }

  export type Payment_sMinAggregateInputType = {
    id_payment?: true
    id_credit_payment?: true
    payment?: true
  }

  export type Payment_sMaxAggregateInputType = {
    id_payment?: true
    id_credit_payment?: true
    payment?: true
  }

  export type Payment_sCountAggregateInputType = {
    id_payment?: true
    id_credit_payment?: true
    payment?: true
    _all?: true
  }

  export type Payment_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_s to aggregate.
     */
    where?: payment_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_s to fetch.
     */
    orderBy?: payment_sOrderByWithRelationInput | payment_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_s
    **/
    _count?: true | Payment_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_sMaxAggregateInputType
  }

  export type GetPayment_sAggregateType<T extends Payment_sAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_s[P]>
      : GetScalarType<T[P], AggregatePayment_s[P]>
  }




  export type payment_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_sWhereInput
    orderBy?: payment_sOrderByWithAggregationInput | payment_sOrderByWithAggregationInput[]
    by: Payment_sScalarFieldEnum[] | Payment_sScalarFieldEnum
    having?: payment_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_sCountAggregateInputType | true
    _avg?: Payment_sAvgAggregateInputType
    _sum?: Payment_sSumAggregateInputType
    _min?: Payment_sMinAggregateInputType
    _max?: Payment_sMaxAggregateInputType
  }

  export type Payment_sGroupByOutputType = {
    id_payment: number
    id_credit_payment: number | null
    payment: number | null
    _count: Payment_sCountAggregateOutputType | null
    _avg: Payment_sAvgAggregateOutputType | null
    _sum: Payment_sSumAggregateOutputType | null
    _min: Payment_sMinAggregateOutputType | null
    _max: Payment_sMaxAggregateOutputType | null
  }

  type GetPayment_sGroupByPayload<T extends payment_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_sGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_sGroupByOutputType[P]>
        }
      >
    >


  export type payment_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_payment?: boolean
    id_credit_payment?: boolean
    payment?: boolean
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }, ExtArgs["result"]["payment_s"]>

  export type payment_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_payment?: boolean
    id_credit_payment?: boolean
    payment?: boolean
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }, ExtArgs["result"]["payment_s"]>

  export type payment_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_payment?: boolean
    id_credit_payment?: boolean
    payment?: boolean
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }, ExtArgs["result"]["payment_s"]>

  export type payment_sSelectScalar = {
    id_payment?: boolean
    id_credit_payment?: boolean
    payment?: boolean
  }

  export type payment_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_payment" | "id_credit_payment" | "payment", ExtArgs["result"]["payment_s"]>
  export type payment_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }
  export type payment_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }
  export type payment_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_s?: boolean | payment_s$credit_sArgs<ExtArgs>
  }

  export type $payment_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_s"
    objects: {
      credit_s: Prisma.$credit_sPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_payment: number
      id_credit_payment: number | null
      payment: number | null
    }, ExtArgs["result"]["payment_s"]>
    composites: {}
  }

  type payment_sGetPayload<S extends boolean | null | undefined | payment_sDefaultArgs> = $Result.GetResult<Prisma.$payment_sPayload, S>

  type payment_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_sCountAggregateInputType | true
    }

  export interface payment_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_s'], meta: { name: 'payment_s' } }
    /**
     * Find zero or one Payment_s that matches the filter.
     * @param {payment_sFindUniqueArgs} args - Arguments to find a Payment_s
     * @example
     * // Get one Payment_s
     * const payment_s = await prisma.payment_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_sFindUniqueArgs>(args: SelectSubset<T, payment_sFindUniqueArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_sFindUniqueOrThrowArgs} args - Arguments to find a Payment_s
     * @example
     * // Get one Payment_s
     * const payment_s = await prisma.payment_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_sFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sFindFirstArgs} args - Arguments to find a Payment_s
     * @example
     * // Get one Payment_s
     * const payment_s = await prisma.payment_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_sFindFirstArgs>(args?: SelectSubset<T, payment_sFindFirstArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sFindFirstOrThrowArgs} args - Arguments to find a Payment_s
     * @example
     * // Get one Payment_s
     * const payment_s = await prisma.payment_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_sFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_s
     * const payment_s = await prisma.payment_s.findMany()
     * 
     * // Get first 10 Payment_s
     * const payment_s = await prisma.payment_s.findMany({ take: 10 })
     * 
     * // Only select the `id_payment`
     * const payment_sWithId_paymentOnly = await prisma.payment_s.findMany({ select: { id_payment: true } })
     * 
     */
    findMany<T extends payment_sFindManyArgs>(args?: SelectSubset<T, payment_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_s.
     * @param {payment_sCreateArgs} args - Arguments to create a Payment_s.
     * @example
     * // Create one Payment_s
     * const Payment_s = await prisma.payment_s.create({
     *   data: {
     *     // ... data to create a Payment_s
     *   }
     * })
     * 
     */
    create<T extends payment_sCreateArgs>(args: SelectSubset<T, payment_sCreateArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_s.
     * @param {payment_sCreateManyArgs} args - Arguments to create many Payment_s.
     * @example
     * // Create many Payment_s
     * const payment_s = await prisma.payment_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_sCreateManyArgs>(args?: SelectSubset<T, payment_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_s and returns the data saved in the database.
     * @param {payment_sCreateManyAndReturnArgs} args - Arguments to create many Payment_s.
     * @example
     * // Create many Payment_s
     * const payment_s = await prisma.payment_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_s and only return the `id_payment`
     * const payment_sWithId_paymentOnly = await prisma.payment_s.createManyAndReturn({
     *   select: { id_payment: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_sCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_s.
     * @param {payment_sDeleteArgs} args - Arguments to delete one Payment_s.
     * @example
     * // Delete one Payment_s
     * const Payment_s = await prisma.payment_s.delete({
     *   where: {
     *     // ... filter to delete one Payment_s
     *   }
     * })
     * 
     */
    delete<T extends payment_sDeleteArgs>(args: SelectSubset<T, payment_sDeleteArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_s.
     * @param {payment_sUpdateArgs} args - Arguments to update one Payment_s.
     * @example
     * // Update one Payment_s
     * const payment_s = await prisma.payment_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_sUpdateArgs>(args: SelectSubset<T, payment_sUpdateArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_s.
     * @param {payment_sDeleteManyArgs} args - Arguments to filter Payment_s to delete.
     * @example
     * // Delete a few Payment_s
     * const { count } = await prisma.payment_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_sDeleteManyArgs>(args?: SelectSubset<T, payment_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_s
     * const payment_s = await prisma.payment_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_sUpdateManyArgs>(args: SelectSubset<T, payment_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_s and returns the data updated in the database.
     * @param {payment_sUpdateManyAndReturnArgs} args - Arguments to update many Payment_s.
     * @example
     * // Update many Payment_s
     * const payment_s = await prisma.payment_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_s and only return the `id_payment`
     * const payment_sWithId_paymentOnly = await prisma.payment_s.updateManyAndReturn({
     *   select: { id_payment: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_sUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_s.
     * @param {payment_sUpsertArgs} args - Arguments to update or create a Payment_s.
     * @example
     * // Update or create a Payment_s
     * const payment_s = await prisma.payment_s.upsert({
     *   create: {
     *     // ... data to create a Payment_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_s we want to update
     *   }
     * })
     */
    upsert<T extends payment_sUpsertArgs>(args: SelectSubset<T, payment_sUpsertArgs<ExtArgs>>): Prisma__payment_sClient<$Result.GetResult<Prisma.$payment_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sCountArgs} args - Arguments to filter Payment_s to count.
     * @example
     * // Count the number of Payment_s
     * const count = await prisma.payment_s.count({
     *   where: {
     *     // ... the filter for the Payment_s we want to count
     *   }
     * })
    **/
    count<T extends payment_sCountArgs>(
      args?: Subset<T, payment_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_sAggregateArgs>(args: Subset<T, Payment_sAggregateArgs>): Prisma.PrismaPromise<GetPayment_sAggregateType<T>>

    /**
     * Group by Payment_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_sGroupByArgs['orderBy'] }
        : { orderBy?: payment_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_s model
   */
  readonly fields: payment_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_s<T extends payment_s$credit_sArgs<ExtArgs> = {}>(args?: Subset<T, payment_s$credit_sArgs<ExtArgs>>): Prisma__credit_sClient<$Result.GetResult<Prisma.$credit_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_s model
   */
  interface payment_sFieldRefs {
    readonly id_payment: FieldRef<"payment_s", 'Int'>
    readonly id_credit_payment: FieldRef<"payment_s", 'Int'>
    readonly payment: FieldRef<"payment_s", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * payment_s findUnique
   */
  export type payment_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter, which payment_s to fetch.
     */
    where: payment_sWhereUniqueInput
  }

  /**
   * payment_s findUniqueOrThrow
   */
  export type payment_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter, which payment_s to fetch.
     */
    where: payment_sWhereUniqueInput
  }

  /**
   * payment_s findFirst
   */
  export type payment_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter, which payment_s to fetch.
     */
    where?: payment_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_s to fetch.
     */
    orderBy?: payment_sOrderByWithRelationInput | payment_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_s.
     */
    cursor?: payment_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_s.
     */
    distinct?: Payment_sScalarFieldEnum | Payment_sScalarFieldEnum[]
  }

  /**
   * payment_s findFirstOrThrow
   */
  export type payment_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter, which payment_s to fetch.
     */
    where?: payment_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_s to fetch.
     */
    orderBy?: payment_sOrderByWithRelationInput | payment_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_s.
     */
    cursor?: payment_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_s.
     */
    distinct?: Payment_sScalarFieldEnum | Payment_sScalarFieldEnum[]
  }

  /**
   * payment_s findMany
   */
  export type payment_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter, which payment_s to fetch.
     */
    where?: payment_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_s to fetch.
     */
    orderBy?: payment_sOrderByWithRelationInput | payment_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_s.
     */
    cursor?: payment_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_s.
     */
    skip?: number
    distinct?: Payment_sScalarFieldEnum | Payment_sScalarFieldEnum[]
  }

  /**
   * payment_s create
   */
  export type payment_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_s.
     */
    data: XOR<payment_sCreateInput, payment_sUncheckedCreateInput>
  }

  /**
   * payment_s createMany
   */
  export type payment_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_s.
     */
    data: payment_sCreateManyInput | payment_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_s createManyAndReturn
   */
  export type payment_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * The data used to create many payment_s.
     */
    data: payment_sCreateManyInput | payment_sCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_s update
   */
  export type payment_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_s.
     */
    data: XOR<payment_sUpdateInput, payment_sUncheckedUpdateInput>
    /**
     * Choose, which payment_s to update.
     */
    where: payment_sWhereUniqueInput
  }

  /**
   * payment_s updateMany
   */
  export type payment_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_s.
     */
    data: XOR<payment_sUpdateManyMutationInput, payment_sUncheckedUpdateManyInput>
    /**
     * Filter which payment_s to update
     */
    where?: payment_sWhereInput
    /**
     * Limit how many payment_s to update.
     */
    limit?: number
  }

  /**
   * payment_s updateManyAndReturn
   */
  export type payment_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * The data used to update payment_s.
     */
    data: XOR<payment_sUpdateManyMutationInput, payment_sUncheckedUpdateManyInput>
    /**
     * Filter which payment_s to update
     */
    where?: payment_sWhereInput
    /**
     * Limit how many payment_s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_s upsert
   */
  export type payment_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_s to update in case it exists.
     */
    where: payment_sWhereUniqueInput
    /**
     * In case the payment_s found by the `where` argument doesn't exist, create a new payment_s with this data.
     */
    create: XOR<payment_sCreateInput, payment_sUncheckedCreateInput>
    /**
     * In case the payment_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_sUpdateInput, payment_sUncheckedUpdateInput>
  }

  /**
   * payment_s delete
   */
  export type payment_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
    /**
     * Filter which payment_s to delete.
     */
    where: payment_sWhereUniqueInput
  }

  /**
   * payment_s deleteMany
   */
  export type payment_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_s to delete
     */
    where?: payment_sWhereInput
    /**
     * Limit how many payment_s to delete.
     */
    limit?: number
  }

  /**
   * payment_s.credit_s
   */
  export type payment_s$credit_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_s
     */
    select?: credit_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_s
     */
    omit?: credit_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_sInclude<ExtArgs> | null
    where?: credit_sWhereInput
  }

  /**
   * payment_s without action
   */
  export type payment_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_s
     */
    select?: payment_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_s
     */
    omit?: payment_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_sInclude<ExtArgs> | null
  }


  /**
   * Model sale_s
   */

  export type AggregateSale_s = {
    _count: Sale_sCountAggregateOutputType | null
    _avg: Sale_sAvgAggregateOutputType | null
    _sum: Sale_sSumAggregateOutputType | null
    _min: Sale_sMinAggregateOutputType | null
    _max: Sale_sMaxAggregateOutputType | null
  }

  export type Sale_sAvgAggregateOutputType = {
    id_sale: number | null
    id_account_sale: number | null
    id_client_sale: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
  }

  export type Sale_sSumAggregateOutputType = {
    id_sale: number | null
    id_account_sale: number | null
    id_client_sale: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
  }

  export type Sale_sMinAggregateOutputType = {
    id_sale: number | null
    id_account_sale: number | null
    id_client_sale: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
  }

  export type Sale_sMaxAggregateOutputType = {
    id_sale: number | null
    id_account_sale: number | null
    id_client_sale: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
  }

  export type Sale_sCountAggregateOutputType = {
    id_sale: number
    id_account_sale: number
    id_client_sale: number
    price_to_sale: number
    price_to_real_product: number
    product_name: number
    _all: number
  }


  export type Sale_sAvgAggregateInputType = {
    id_sale?: true
    id_account_sale?: true
    id_client_sale?: true
    price_to_sale?: true
    price_to_real_product?: true
  }

  export type Sale_sSumAggregateInputType = {
    id_sale?: true
    id_account_sale?: true
    id_client_sale?: true
    price_to_sale?: true
    price_to_real_product?: true
  }

  export type Sale_sMinAggregateInputType = {
    id_sale?: true
    id_account_sale?: true
    id_client_sale?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
  }

  export type Sale_sMaxAggregateInputType = {
    id_sale?: true
    id_account_sale?: true
    id_client_sale?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
  }

  export type Sale_sCountAggregateInputType = {
    id_sale?: true
    id_account_sale?: true
    id_client_sale?: true
    price_to_sale?: true
    price_to_real_product?: true
    product_name?: true
    _all?: true
  }

  export type Sale_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sale_s to aggregate.
     */
    where?: sale_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_s to fetch.
     */
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sale_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sale_s
    **/
    _count?: true | Sale_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sale_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sale_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sale_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sale_sMaxAggregateInputType
  }

  export type GetSale_sAggregateType<T extends Sale_sAggregateArgs> = {
        [P in keyof T & keyof AggregateSale_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale_s[P]>
      : GetScalarType<T[P], AggregateSale_s[P]>
  }




  export type sale_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sale_sWhereInput
    orderBy?: sale_sOrderByWithAggregationInput | sale_sOrderByWithAggregationInput[]
    by: Sale_sScalarFieldEnum[] | Sale_sScalarFieldEnum
    having?: sale_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sale_sCountAggregateInputType | true
    _avg?: Sale_sAvgAggregateInputType
    _sum?: Sale_sSumAggregateInputType
    _min?: Sale_sMinAggregateInputType
    _max?: Sale_sMaxAggregateInputType
  }

  export type Sale_sGroupByOutputType = {
    id_sale: number
    id_account_sale: number | null
    id_client_sale: number | null
    price_to_sale: number | null
    price_to_real_product: number | null
    product_name: string | null
    _count: Sale_sCountAggregateOutputType | null
    _avg: Sale_sAvgAggregateOutputType | null
    _sum: Sale_sSumAggregateOutputType | null
    _min: Sale_sMinAggregateOutputType | null
    _max: Sale_sMaxAggregateOutputType | null
  }

  type GetSale_sGroupByPayload<T extends sale_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sale_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sale_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sale_sGroupByOutputType[P]>
            : GetScalarType<T[P], Sale_sGroupByOutputType[P]>
        }
      >
    >


  export type sale_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sale?: boolean
    id_account_sale?: boolean
    id_client_sale?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }, ExtArgs["result"]["sale_s"]>

  export type sale_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sale?: boolean
    id_account_sale?: boolean
    id_client_sale?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }, ExtArgs["result"]["sale_s"]>

  export type sale_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sale?: boolean
    id_account_sale?: boolean
    id_client_sale?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }, ExtArgs["result"]["sale_s"]>

  export type sale_sSelectScalar = {
    id_sale?: boolean
    id_account_sale?: boolean
    id_client_sale?: boolean
    price_to_sale?: boolean
    price_to_real_product?: boolean
    product_name?: boolean
  }

  export type sale_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_sale" | "id_account_sale" | "id_client_sale" | "price_to_sale" | "price_to_real_product" | "product_name", ExtArgs["result"]["sale_s"]>
  export type sale_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }
  export type sale_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }
  export type sale_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | sale_s$account_sArgs<ExtArgs>
    client_s?: boolean | sale_s$client_sArgs<ExtArgs>
  }

  export type $sale_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sale_s"
    objects: {
      account_s: Prisma.$account_sPayload<ExtArgs> | null
      client_s: Prisma.$client_sPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_sale: number
      id_account_sale: number | null
      id_client_sale: number | null
      price_to_sale: number | null
      price_to_real_product: number | null
      product_name: string | null
    }, ExtArgs["result"]["sale_s"]>
    composites: {}
  }

  type sale_sGetPayload<S extends boolean | null | undefined | sale_sDefaultArgs> = $Result.GetResult<Prisma.$sale_sPayload, S>

  type sale_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sale_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sale_sCountAggregateInputType | true
    }

  export interface sale_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sale_s'], meta: { name: 'sale_s' } }
    /**
     * Find zero or one Sale_s that matches the filter.
     * @param {sale_sFindUniqueArgs} args - Arguments to find a Sale_s
     * @example
     * // Get one Sale_s
     * const sale_s = await prisma.sale_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sale_sFindUniqueArgs>(args: SelectSubset<T, sale_sFindUniqueArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sale_sFindUniqueOrThrowArgs} args - Arguments to find a Sale_s
     * @example
     * // Get one Sale_s
     * const sale_s = await prisma.sale_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sale_sFindUniqueOrThrowArgs>(args: SelectSubset<T, sale_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sFindFirstArgs} args - Arguments to find a Sale_s
     * @example
     * // Get one Sale_s
     * const sale_s = await prisma.sale_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sale_sFindFirstArgs>(args?: SelectSubset<T, sale_sFindFirstArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sFindFirstOrThrowArgs} args - Arguments to find a Sale_s
     * @example
     * // Get one Sale_s
     * const sale_s = await prisma.sale_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sale_sFindFirstOrThrowArgs>(args?: SelectSubset<T, sale_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sale_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sale_s
     * const sale_s = await prisma.sale_s.findMany()
     * 
     * // Get first 10 Sale_s
     * const sale_s = await prisma.sale_s.findMany({ take: 10 })
     * 
     * // Only select the `id_sale`
     * const sale_sWithId_saleOnly = await prisma.sale_s.findMany({ select: { id_sale: true } })
     * 
     */
    findMany<T extends sale_sFindManyArgs>(args?: SelectSubset<T, sale_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale_s.
     * @param {sale_sCreateArgs} args - Arguments to create a Sale_s.
     * @example
     * // Create one Sale_s
     * const Sale_s = await prisma.sale_s.create({
     *   data: {
     *     // ... data to create a Sale_s
     *   }
     * })
     * 
     */
    create<T extends sale_sCreateArgs>(args: SelectSubset<T, sale_sCreateArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sale_s.
     * @param {sale_sCreateManyArgs} args - Arguments to create many Sale_s.
     * @example
     * // Create many Sale_s
     * const sale_s = await prisma.sale_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sale_sCreateManyArgs>(args?: SelectSubset<T, sale_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sale_s and returns the data saved in the database.
     * @param {sale_sCreateManyAndReturnArgs} args - Arguments to create many Sale_s.
     * @example
     * // Create many Sale_s
     * const sale_s = await prisma.sale_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sale_s and only return the `id_sale`
     * const sale_sWithId_saleOnly = await prisma.sale_s.createManyAndReturn({
     *   select: { id_sale: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sale_sCreateManyAndReturnArgs>(args?: SelectSubset<T, sale_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale_s.
     * @param {sale_sDeleteArgs} args - Arguments to delete one Sale_s.
     * @example
     * // Delete one Sale_s
     * const Sale_s = await prisma.sale_s.delete({
     *   where: {
     *     // ... filter to delete one Sale_s
     *   }
     * })
     * 
     */
    delete<T extends sale_sDeleteArgs>(args: SelectSubset<T, sale_sDeleteArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale_s.
     * @param {sale_sUpdateArgs} args - Arguments to update one Sale_s.
     * @example
     * // Update one Sale_s
     * const sale_s = await prisma.sale_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sale_sUpdateArgs>(args: SelectSubset<T, sale_sUpdateArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sale_s.
     * @param {sale_sDeleteManyArgs} args - Arguments to filter Sale_s to delete.
     * @example
     * // Delete a few Sale_s
     * const { count } = await prisma.sale_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sale_sDeleteManyArgs>(args?: SelectSubset<T, sale_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sale_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sale_s
     * const sale_s = await prisma.sale_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sale_sUpdateManyArgs>(args: SelectSubset<T, sale_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sale_s and returns the data updated in the database.
     * @param {sale_sUpdateManyAndReturnArgs} args - Arguments to update many Sale_s.
     * @example
     * // Update many Sale_s
     * const sale_s = await prisma.sale_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sale_s and only return the `id_sale`
     * const sale_sWithId_saleOnly = await prisma.sale_s.updateManyAndReturn({
     *   select: { id_sale: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sale_sUpdateManyAndReturnArgs>(args: SelectSubset<T, sale_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale_s.
     * @param {sale_sUpsertArgs} args - Arguments to update or create a Sale_s.
     * @example
     * // Update or create a Sale_s
     * const sale_s = await prisma.sale_s.upsert({
     *   create: {
     *     // ... data to create a Sale_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale_s we want to update
     *   }
     * })
     */
    upsert<T extends sale_sUpsertArgs>(args: SelectSubset<T, sale_sUpsertArgs<ExtArgs>>): Prisma__sale_sClient<$Result.GetResult<Prisma.$sale_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sale_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sCountArgs} args - Arguments to filter Sale_s to count.
     * @example
     * // Count the number of Sale_s
     * const count = await prisma.sale_s.count({
     *   where: {
     *     // ... the filter for the Sale_s we want to count
     *   }
     * })
    **/
    count<T extends sale_sCountArgs>(
      args?: Subset<T, sale_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sale_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sale_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sale_sAggregateArgs>(args: Subset<T, Sale_sAggregateArgs>): Prisma.PrismaPromise<GetSale_sAggregateType<T>>

    /**
     * Group by Sale_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sale_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sale_sGroupByArgs['orderBy'] }
        : { orderBy?: sale_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sale_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSale_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sale_s model
   */
  readonly fields: sale_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sale_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sale_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_s<T extends sale_s$account_sArgs<ExtArgs> = {}>(args?: Subset<T, sale_s$account_sArgs<ExtArgs>>): Prisma__account_sClient<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client_s<T extends sale_s$client_sArgs<ExtArgs> = {}>(args?: Subset<T, sale_s$client_sArgs<ExtArgs>>): Prisma__client_sClient<$Result.GetResult<Prisma.$client_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sale_s model
   */
  interface sale_sFieldRefs {
    readonly id_sale: FieldRef<"sale_s", 'Int'>
    readonly id_account_sale: FieldRef<"sale_s", 'Int'>
    readonly id_client_sale: FieldRef<"sale_s", 'Int'>
    readonly price_to_sale: FieldRef<"sale_s", 'Float'>
    readonly price_to_real_product: FieldRef<"sale_s", 'Float'>
    readonly product_name: FieldRef<"sale_s", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sale_s findUnique
   */
  export type sale_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter, which sale_s to fetch.
     */
    where: sale_sWhereUniqueInput
  }

  /**
   * sale_s findUniqueOrThrow
   */
  export type sale_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter, which sale_s to fetch.
     */
    where: sale_sWhereUniqueInput
  }

  /**
   * sale_s findFirst
   */
  export type sale_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter, which sale_s to fetch.
     */
    where?: sale_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_s to fetch.
     */
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_s.
     */
    cursor?: sale_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_s.
     */
    distinct?: Sale_sScalarFieldEnum | Sale_sScalarFieldEnum[]
  }

  /**
   * sale_s findFirstOrThrow
   */
  export type sale_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter, which sale_s to fetch.
     */
    where?: sale_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_s to fetch.
     */
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_s.
     */
    cursor?: sale_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_s.
     */
    distinct?: Sale_sScalarFieldEnum | Sale_sScalarFieldEnum[]
  }

  /**
   * sale_s findMany
   */
  export type sale_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter, which sale_s to fetch.
     */
    where?: sale_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_s to fetch.
     */
    orderBy?: sale_sOrderByWithRelationInput | sale_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sale_s.
     */
    cursor?: sale_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_s.
     */
    skip?: number
    distinct?: Sale_sScalarFieldEnum | Sale_sScalarFieldEnum[]
  }

  /**
   * sale_s create
   */
  export type sale_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * The data needed to create a sale_s.
     */
    data: XOR<sale_sCreateInput, sale_sUncheckedCreateInput>
  }

  /**
   * sale_s createMany
   */
  export type sale_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sale_s.
     */
    data: sale_sCreateManyInput | sale_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sale_s createManyAndReturn
   */
  export type sale_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * The data used to create many sale_s.
     */
    data: sale_sCreateManyInput | sale_sCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sale_s update
   */
  export type sale_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * The data needed to update a sale_s.
     */
    data: XOR<sale_sUpdateInput, sale_sUncheckedUpdateInput>
    /**
     * Choose, which sale_s to update.
     */
    where: sale_sWhereUniqueInput
  }

  /**
   * sale_s updateMany
   */
  export type sale_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sale_s.
     */
    data: XOR<sale_sUpdateManyMutationInput, sale_sUncheckedUpdateManyInput>
    /**
     * Filter which sale_s to update
     */
    where?: sale_sWhereInput
    /**
     * Limit how many sale_s to update.
     */
    limit?: number
  }

  /**
   * sale_s updateManyAndReturn
   */
  export type sale_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * The data used to update sale_s.
     */
    data: XOR<sale_sUpdateManyMutationInput, sale_sUncheckedUpdateManyInput>
    /**
     * Filter which sale_s to update
     */
    where?: sale_sWhereInput
    /**
     * Limit how many sale_s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sale_s upsert
   */
  export type sale_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * The filter to search for the sale_s to update in case it exists.
     */
    where: sale_sWhereUniqueInput
    /**
     * In case the sale_s found by the `where` argument doesn't exist, create a new sale_s with this data.
     */
    create: XOR<sale_sCreateInput, sale_sUncheckedCreateInput>
    /**
     * In case the sale_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sale_sUpdateInput, sale_sUncheckedUpdateInput>
  }

  /**
   * sale_s delete
   */
  export type sale_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
    /**
     * Filter which sale_s to delete.
     */
    where: sale_sWhereUniqueInput
  }

  /**
   * sale_s deleteMany
   */
  export type sale_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sale_s to delete
     */
    where?: sale_sWhereInput
    /**
     * Limit how many sale_s to delete.
     */
    limit?: number
  }

  /**
   * sale_s.account_s
   */
  export type sale_s$account_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    where?: account_sWhereInput
  }

  /**
   * sale_s.client_s
   */
  export type sale_s$client_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_s
     */
    select?: client_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_s
     */
    omit?: client_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_sInclude<ExtArgs> | null
    where?: client_sWhereInput
  }

  /**
   * sale_s without action
   */
  export type sale_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_s
     */
    select?: sale_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_s
     */
    omit?: sale_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sale_sInclude<ExtArgs> | null
  }


  /**
   * Model user_s
   */

  export type AggregateUser_s = {
    _count: User_sCountAggregateOutputType | null
    _avg: User_sAvgAggregateOutputType | null
    _sum: User_sSumAggregateOutputType | null
    _min: User_sMinAggregateOutputType | null
    _max: User_sMaxAggregateOutputType | null
  }

  export type User_sAvgAggregateOutputType = {
    id_user: number | null
  }

  export type User_sSumAggregateOutputType = {
    id_user: number | null
  }

  export type User_sMinAggregateOutputType = {
    id_user: number | null
    name_user: string | null
    first_last_name: string | null
    second_last_name: string | null
  }

  export type User_sMaxAggregateOutputType = {
    id_user: number | null
    name_user: string | null
    first_last_name: string | null
    second_last_name: string | null
  }

  export type User_sCountAggregateOutputType = {
    id_user: number
    name_user: number
    first_last_name: number
    second_last_name: number
    _all: number
  }


  export type User_sAvgAggregateInputType = {
    id_user?: true
  }

  export type User_sSumAggregateInputType = {
    id_user?: true
  }

  export type User_sMinAggregateInputType = {
    id_user?: true
    name_user?: true
    first_last_name?: true
    second_last_name?: true
  }

  export type User_sMaxAggregateInputType = {
    id_user?: true
    name_user?: true
    first_last_name?: true
    second_last_name?: true
  }

  export type User_sCountAggregateInputType = {
    id_user?: true
    name_user?: true
    first_last_name?: true
    second_last_name?: true
    _all?: true
  }

  export type User_sAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_s to aggregate.
     */
    where?: user_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_s to fetch.
     */
    orderBy?: user_sOrderByWithRelationInput | user_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_s
    **/
    _count?: true | User_sCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_sAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_sSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_sMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_sMaxAggregateInputType
  }

  export type GetUser_sAggregateType<T extends User_sAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_s]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_s[P]>
      : GetScalarType<T[P], AggregateUser_s[P]>
  }




  export type user_sGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_sWhereInput
    orderBy?: user_sOrderByWithAggregationInput | user_sOrderByWithAggregationInput[]
    by: User_sScalarFieldEnum[] | User_sScalarFieldEnum
    having?: user_sScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_sCountAggregateInputType | true
    _avg?: User_sAvgAggregateInputType
    _sum?: User_sSumAggregateInputType
    _min?: User_sMinAggregateInputType
    _max?: User_sMaxAggregateInputType
  }

  export type User_sGroupByOutputType = {
    id_user: number
    name_user: string | null
    first_last_name: string | null
    second_last_name: string | null
    _count: User_sCountAggregateOutputType | null
    _avg: User_sAvgAggregateOutputType | null
    _sum: User_sSumAggregateOutputType | null
    _min: User_sMinAggregateOutputType | null
    _max: User_sMaxAggregateOutputType | null
  }

  type GetUser_sGroupByPayload<T extends user_sGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_sGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_sGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_sGroupByOutputType[P]>
            : GetScalarType<T[P], User_sGroupByOutputType[P]>
        }
      >
    >


  export type user_sSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    name_user?: boolean
    first_last_name?: boolean
    second_last_name?: boolean
    account_s?: boolean | user_s$account_sArgs<ExtArgs>
    _count?: boolean | User_sCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_s"]>

  export type user_sSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    name_user?: boolean
    first_last_name?: boolean
    second_last_name?: boolean
  }, ExtArgs["result"]["user_s"]>

  export type user_sSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    name_user?: boolean
    first_last_name?: boolean
    second_last_name?: boolean
  }, ExtArgs["result"]["user_s"]>

  export type user_sSelectScalar = {
    id_user?: boolean
    name_user?: boolean
    first_last_name?: boolean
    second_last_name?: boolean
  }

  export type user_sOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_user" | "name_user" | "first_last_name" | "second_last_name", ExtArgs["result"]["user_s"]>
  export type user_sInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_s?: boolean | user_s$account_sArgs<ExtArgs>
    _count?: boolean | User_sCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_sIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type user_sIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $user_sPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_s"
    objects: {
      account_s: Prisma.$account_sPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_user: number
      name_user: string | null
      first_last_name: string | null
      second_last_name: string | null
    }, ExtArgs["result"]["user_s"]>
    composites: {}
  }

  type user_sGetPayload<S extends boolean | null | undefined | user_sDefaultArgs> = $Result.GetResult<Prisma.$user_sPayload, S>

  type user_sCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_sFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_sCountAggregateInputType | true
    }

  export interface user_sDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_s'], meta: { name: 'user_s' } }
    /**
     * Find zero or one User_s that matches the filter.
     * @param {user_sFindUniqueArgs} args - Arguments to find a User_s
     * @example
     * // Get one User_s
     * const user_s = await prisma.user_s.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_sFindUniqueArgs>(args: SelectSubset<T, user_sFindUniqueArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_s that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_sFindUniqueOrThrowArgs} args - Arguments to find a User_s
     * @example
     * // Get one User_s
     * const user_s = await prisma.user_s.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_sFindUniqueOrThrowArgs>(args: SelectSubset<T, user_sFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sFindFirstArgs} args - Arguments to find a User_s
     * @example
     * // Get one User_s
     * const user_s = await prisma.user_s.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_sFindFirstArgs>(args?: SelectSubset<T, user_sFindFirstArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_s that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sFindFirstOrThrowArgs} args - Arguments to find a User_s
     * @example
     * // Get one User_s
     * const user_s = await prisma.user_s.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_sFindFirstOrThrowArgs>(args?: SelectSubset<T, user_sFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_s
     * const user_s = await prisma.user_s.findMany()
     * 
     * // Get first 10 User_s
     * const user_s = await prisma.user_s.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const user_sWithId_userOnly = await prisma.user_s.findMany({ select: { id_user: true } })
     * 
     */
    findMany<T extends user_sFindManyArgs>(args?: SelectSubset<T, user_sFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_s.
     * @param {user_sCreateArgs} args - Arguments to create a User_s.
     * @example
     * // Create one User_s
     * const User_s = await prisma.user_s.create({
     *   data: {
     *     // ... data to create a User_s
     *   }
     * })
     * 
     */
    create<T extends user_sCreateArgs>(args: SelectSubset<T, user_sCreateArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_s.
     * @param {user_sCreateManyArgs} args - Arguments to create many User_s.
     * @example
     * // Create many User_s
     * const user_s = await prisma.user_s.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_sCreateManyArgs>(args?: SelectSubset<T, user_sCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_s and returns the data saved in the database.
     * @param {user_sCreateManyAndReturnArgs} args - Arguments to create many User_s.
     * @example
     * // Create many User_s
     * const user_s = await prisma.user_s.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_s and only return the `id_user`
     * const user_sWithId_userOnly = await prisma.user_s.createManyAndReturn({
     *   select: { id_user: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_sCreateManyAndReturnArgs>(args?: SelectSubset<T, user_sCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_s.
     * @param {user_sDeleteArgs} args - Arguments to delete one User_s.
     * @example
     * // Delete one User_s
     * const User_s = await prisma.user_s.delete({
     *   where: {
     *     // ... filter to delete one User_s
     *   }
     * })
     * 
     */
    delete<T extends user_sDeleteArgs>(args: SelectSubset<T, user_sDeleteArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_s.
     * @param {user_sUpdateArgs} args - Arguments to update one User_s.
     * @example
     * // Update one User_s
     * const user_s = await prisma.user_s.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_sUpdateArgs>(args: SelectSubset<T, user_sUpdateArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_s.
     * @param {user_sDeleteManyArgs} args - Arguments to filter User_s to delete.
     * @example
     * // Delete a few User_s
     * const { count } = await prisma.user_s.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_sDeleteManyArgs>(args?: SelectSubset<T, user_sDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_s
     * const user_s = await prisma.user_s.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_sUpdateManyArgs>(args: SelectSubset<T, user_sUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_s and returns the data updated in the database.
     * @param {user_sUpdateManyAndReturnArgs} args - Arguments to update many User_s.
     * @example
     * // Update many User_s
     * const user_s = await prisma.user_s.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_s and only return the `id_user`
     * const user_sWithId_userOnly = await prisma.user_s.updateManyAndReturn({
     *   select: { id_user: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_sUpdateManyAndReturnArgs>(args: SelectSubset<T, user_sUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_s.
     * @param {user_sUpsertArgs} args - Arguments to update or create a User_s.
     * @example
     * // Update or create a User_s
     * const user_s = await prisma.user_s.upsert({
     *   create: {
     *     // ... data to create a User_s
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_s we want to update
     *   }
     * })
     */
    upsert<T extends user_sUpsertArgs>(args: SelectSubset<T, user_sUpsertArgs<ExtArgs>>): Prisma__user_sClient<$Result.GetResult<Prisma.$user_sPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sCountArgs} args - Arguments to filter User_s to count.
     * @example
     * // Count the number of User_s
     * const count = await prisma.user_s.count({
     *   where: {
     *     // ... the filter for the User_s we want to count
     *   }
     * })
    **/
    count<T extends user_sCountArgs>(
      args?: Subset<T, user_sCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_sCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_sAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_sAggregateArgs>(args: Subset<T, User_sAggregateArgs>): Prisma.PrismaPromise<GetUser_sAggregateType<T>>

    /**
     * Group by User_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_sGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_sGroupByArgs['orderBy'] }
        : { orderBy?: user_sGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_sGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_sGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_s model
   */
  readonly fields: user_sFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_s.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_sClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_s<T extends user_s$account_sArgs<ExtArgs> = {}>(args?: Subset<T, user_s$account_sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$account_sPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_s model
   */
  interface user_sFieldRefs {
    readonly id_user: FieldRef<"user_s", 'Int'>
    readonly name_user: FieldRef<"user_s", 'String'>
    readonly first_last_name: FieldRef<"user_s", 'String'>
    readonly second_last_name: FieldRef<"user_s", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_s findUnique
   */
  export type user_sFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter, which user_s to fetch.
     */
    where: user_sWhereUniqueInput
  }

  /**
   * user_s findUniqueOrThrow
   */
  export type user_sFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter, which user_s to fetch.
     */
    where: user_sWhereUniqueInput
  }

  /**
   * user_s findFirst
   */
  export type user_sFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter, which user_s to fetch.
     */
    where?: user_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_s to fetch.
     */
    orderBy?: user_sOrderByWithRelationInput | user_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_s.
     */
    cursor?: user_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_s.
     */
    distinct?: User_sScalarFieldEnum | User_sScalarFieldEnum[]
  }

  /**
   * user_s findFirstOrThrow
   */
  export type user_sFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter, which user_s to fetch.
     */
    where?: user_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_s to fetch.
     */
    orderBy?: user_sOrderByWithRelationInput | user_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_s.
     */
    cursor?: user_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_s.
     */
    distinct?: User_sScalarFieldEnum | User_sScalarFieldEnum[]
  }

  /**
   * user_s findMany
   */
  export type user_sFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter, which user_s to fetch.
     */
    where?: user_sWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_s to fetch.
     */
    orderBy?: user_sOrderByWithRelationInput | user_sOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_s.
     */
    cursor?: user_sWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_s.
     */
    skip?: number
    distinct?: User_sScalarFieldEnum | User_sScalarFieldEnum[]
  }

  /**
   * user_s create
   */
  export type user_sCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * The data needed to create a user_s.
     */
    data: XOR<user_sCreateInput, user_sUncheckedCreateInput>
  }

  /**
   * user_s createMany
   */
  export type user_sCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_s.
     */
    data: user_sCreateManyInput | user_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_s createManyAndReturn
   */
  export type user_sCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * The data used to create many user_s.
     */
    data: user_sCreateManyInput | user_sCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_s update
   */
  export type user_sUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * The data needed to update a user_s.
     */
    data: XOR<user_sUpdateInput, user_sUncheckedUpdateInput>
    /**
     * Choose, which user_s to update.
     */
    where: user_sWhereUniqueInput
  }

  /**
   * user_s updateMany
   */
  export type user_sUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_s.
     */
    data: XOR<user_sUpdateManyMutationInput, user_sUncheckedUpdateManyInput>
    /**
     * Filter which user_s to update
     */
    where?: user_sWhereInput
    /**
     * Limit how many user_s to update.
     */
    limit?: number
  }

  /**
   * user_s updateManyAndReturn
   */
  export type user_sUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * The data used to update user_s.
     */
    data: XOR<user_sUpdateManyMutationInput, user_sUncheckedUpdateManyInput>
    /**
     * Filter which user_s to update
     */
    where?: user_sWhereInput
    /**
     * Limit how many user_s to update.
     */
    limit?: number
  }

  /**
   * user_s upsert
   */
  export type user_sUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * The filter to search for the user_s to update in case it exists.
     */
    where: user_sWhereUniqueInput
    /**
     * In case the user_s found by the `where` argument doesn't exist, create a new user_s with this data.
     */
    create: XOR<user_sCreateInput, user_sUncheckedCreateInput>
    /**
     * In case the user_s was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_sUpdateInput, user_sUncheckedUpdateInput>
  }

  /**
   * user_s delete
   */
  export type user_sDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
    /**
     * Filter which user_s to delete.
     */
    where: user_sWhereUniqueInput
  }

  /**
   * user_s deleteMany
   */
  export type user_sDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_s to delete
     */
    where?: user_sWhereInput
    /**
     * Limit how many user_s to delete.
     */
    limit?: number
  }

  /**
   * user_s.account_s
   */
  export type user_s$account_sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_s
     */
    select?: account_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_s
     */
    omit?: account_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_sInclude<ExtArgs> | null
    where?: account_sWhereInput
    orderBy?: account_sOrderByWithRelationInput | account_sOrderByWithRelationInput[]
    cursor?: account_sWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Account_sScalarFieldEnum | Account_sScalarFieldEnum[]
  }

  /**
   * user_s without action
   */
  export type user_sDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_s
     */
    select?: user_sSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_s
     */
    omit?: user_sOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Account_sScalarFieldEnum: {
    id_account: 'id_account',
    id_user_account: 'id_user_account',
    e_mail: 'e_mail',
    password_: 'password_',
    name_company: 'name_company',
    general_valance_account: 'general_valance_account'
  };

  export type Account_sScalarFieldEnum = (typeof Account_sScalarFieldEnum)[keyof typeof Account_sScalarFieldEnum]


  export const Client_sScalarFieldEnum: {
    id_client: 'id_client',
    id_account_client: 'id_account_client',
    address_client: 'address_client',
    name_client: 'name_client',
    valance_credit_client: 'valance_credit_client'
  };

  export type Client_sScalarFieldEnum = (typeof Client_sScalarFieldEnum)[keyof typeof Client_sScalarFieldEnum]


  export const Credit_sScalarFieldEnum: {
    id_credit: 'id_credit',
    id_account_credit: 'id_account_credit',
    id_client_credit: 'id_client_credit',
    price_to_sale: 'price_to_sale',
    price_to_real_product: 'price_to_real_product',
    product_name: 'product_name',
    total_payment_acumulation: 'total_payment_acumulation',
    credit_state: 'credit_state'
  };

  export type Credit_sScalarFieldEnum = (typeof Credit_sScalarFieldEnum)[keyof typeof Credit_sScalarFieldEnum]


  export const Payment_sScalarFieldEnum: {
    id_payment: 'id_payment',
    id_credit_payment: 'id_credit_payment',
    payment: 'payment'
  };

  export type Payment_sScalarFieldEnum = (typeof Payment_sScalarFieldEnum)[keyof typeof Payment_sScalarFieldEnum]


  export const Sale_sScalarFieldEnum: {
    id_sale: 'id_sale',
    id_account_sale: 'id_account_sale',
    id_client_sale: 'id_client_sale',
    price_to_sale: 'price_to_sale',
    price_to_real_product: 'price_to_real_product',
    product_name: 'product_name'
  };

  export type Sale_sScalarFieldEnum = (typeof Sale_sScalarFieldEnum)[keyof typeof Sale_sScalarFieldEnum]


  export const User_sScalarFieldEnum: {
    id_user: 'id_user',
    name_user: 'name_user',
    first_last_name: 'first_last_name',
    second_last_name: 'second_last_name'
  };

  export type User_sScalarFieldEnum = (typeof User_sScalarFieldEnum)[keyof typeof User_sScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type account_sWhereInput = {
    AND?: account_sWhereInput | account_sWhereInput[]
    OR?: account_sWhereInput[]
    NOT?: account_sWhereInput | account_sWhereInput[]
    id_account?: IntFilter<"account_s"> | number
    id_user_account?: IntNullableFilter<"account_s"> | number | null
    e_mail?: StringNullableFilter<"account_s"> | string | null
    password_?: StringNullableFilter<"account_s"> | string | null
    name_company?: StringNullableFilter<"account_s"> | string | null
    general_valance_account?: FloatNullableFilter<"account_s"> | number | null
    user_s?: XOR<User_sNullableScalarRelationFilter, user_sWhereInput> | null
    credit_s?: Credit_sListRelationFilter
    sale_s?: Sale_sListRelationFilter
  }

  export type account_sOrderByWithRelationInput = {
    id_account?: SortOrder
    id_user_account?: SortOrderInput | SortOrder
    e_mail?: SortOrderInput | SortOrder
    password_?: SortOrderInput | SortOrder
    name_company?: SortOrderInput | SortOrder
    general_valance_account?: SortOrderInput | SortOrder
    user_s?: user_sOrderByWithRelationInput
    credit_s?: credit_sOrderByRelationAggregateInput
    sale_s?: sale_sOrderByRelationAggregateInput
  }

  export type account_sWhereUniqueInput = Prisma.AtLeast<{
    id_account?: number
    AND?: account_sWhereInput | account_sWhereInput[]
    OR?: account_sWhereInput[]
    NOT?: account_sWhereInput | account_sWhereInput[]
    id_user_account?: IntNullableFilter<"account_s"> | number | null
    e_mail?: StringNullableFilter<"account_s"> | string | null
    password_?: StringNullableFilter<"account_s"> | string | null
    name_company?: StringNullableFilter<"account_s"> | string | null
    general_valance_account?: FloatNullableFilter<"account_s"> | number | null
    user_s?: XOR<User_sNullableScalarRelationFilter, user_sWhereInput> | null
    credit_s?: Credit_sListRelationFilter
    sale_s?: Sale_sListRelationFilter
  }, "id_account">

  export type account_sOrderByWithAggregationInput = {
    id_account?: SortOrder
    id_user_account?: SortOrderInput | SortOrder
    e_mail?: SortOrderInput | SortOrder
    password_?: SortOrderInput | SortOrder
    name_company?: SortOrderInput | SortOrder
    general_valance_account?: SortOrderInput | SortOrder
    _count?: account_sCountOrderByAggregateInput
    _avg?: account_sAvgOrderByAggregateInput
    _max?: account_sMaxOrderByAggregateInput
    _min?: account_sMinOrderByAggregateInput
    _sum?: account_sSumOrderByAggregateInput
  }

  export type account_sScalarWhereWithAggregatesInput = {
    AND?: account_sScalarWhereWithAggregatesInput | account_sScalarWhereWithAggregatesInput[]
    OR?: account_sScalarWhereWithAggregatesInput[]
    NOT?: account_sScalarWhereWithAggregatesInput | account_sScalarWhereWithAggregatesInput[]
    id_account?: IntWithAggregatesFilter<"account_s"> | number
    id_user_account?: IntNullableWithAggregatesFilter<"account_s"> | number | null
    e_mail?: StringNullableWithAggregatesFilter<"account_s"> | string | null
    password_?: StringNullableWithAggregatesFilter<"account_s"> | string | null
    name_company?: StringNullableWithAggregatesFilter<"account_s"> | string | null
    general_valance_account?: FloatNullableWithAggregatesFilter<"account_s"> | number | null
  }

  export type client_sWhereInput = {
    AND?: client_sWhereInput | client_sWhereInput[]
    OR?: client_sWhereInput[]
    NOT?: client_sWhereInput | client_sWhereInput[]
    id_client?: IntFilter<"client_s"> | number
    id_account_client?: IntNullableFilter<"client_s"> | number | null
    address_client?: StringNullableFilter<"client_s"> | string | null
    name_client?: StringNullableFilter<"client_s"> | string | null
    valance_credit_client?: FloatNullableFilter<"client_s"> | number | null
    credit_s?: Credit_sListRelationFilter
    sale_s?: Sale_sListRelationFilter
  }

  export type client_sOrderByWithRelationInput = {
    id_client?: SortOrder
    id_account_client?: SortOrderInput | SortOrder
    address_client?: SortOrderInput | SortOrder
    name_client?: SortOrderInput | SortOrder
    valance_credit_client?: SortOrderInput | SortOrder
    credit_s?: credit_sOrderByRelationAggregateInput
    sale_s?: sale_sOrderByRelationAggregateInput
  }

  export type client_sWhereUniqueInput = Prisma.AtLeast<{
    id_client?: number
    AND?: client_sWhereInput | client_sWhereInput[]
    OR?: client_sWhereInput[]
    NOT?: client_sWhereInput | client_sWhereInput[]
    id_account_client?: IntNullableFilter<"client_s"> | number | null
    address_client?: StringNullableFilter<"client_s"> | string | null
    name_client?: StringNullableFilter<"client_s"> | string | null
    valance_credit_client?: FloatNullableFilter<"client_s"> | number | null
    credit_s?: Credit_sListRelationFilter
    sale_s?: Sale_sListRelationFilter
  }, "id_client">

  export type client_sOrderByWithAggregationInput = {
    id_client?: SortOrder
    id_account_client?: SortOrderInput | SortOrder
    address_client?: SortOrderInput | SortOrder
    name_client?: SortOrderInput | SortOrder
    valance_credit_client?: SortOrderInput | SortOrder
    _count?: client_sCountOrderByAggregateInput
    _avg?: client_sAvgOrderByAggregateInput
    _max?: client_sMaxOrderByAggregateInput
    _min?: client_sMinOrderByAggregateInput
    _sum?: client_sSumOrderByAggregateInput
  }

  export type client_sScalarWhereWithAggregatesInput = {
    AND?: client_sScalarWhereWithAggregatesInput | client_sScalarWhereWithAggregatesInput[]
    OR?: client_sScalarWhereWithAggregatesInput[]
    NOT?: client_sScalarWhereWithAggregatesInput | client_sScalarWhereWithAggregatesInput[]
    id_client?: IntWithAggregatesFilter<"client_s"> | number
    id_account_client?: IntNullableWithAggregatesFilter<"client_s"> | number | null
    address_client?: StringNullableWithAggregatesFilter<"client_s"> | string | null
    name_client?: StringNullableWithAggregatesFilter<"client_s"> | string | null
    valance_credit_client?: FloatNullableWithAggregatesFilter<"client_s"> | number | null
  }

  export type credit_sWhereInput = {
    AND?: credit_sWhereInput | credit_sWhereInput[]
    OR?: credit_sWhereInput[]
    NOT?: credit_sWhereInput | credit_sWhereInput[]
    id_credit?: IntFilter<"credit_s"> | number
    id_account_credit?: IntNullableFilter<"credit_s"> | number | null
    id_client_credit?: IntNullableFilter<"credit_s"> | number | null
    price_to_sale?: FloatNullableFilter<"credit_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"credit_s"> | number | null
    product_name?: StringNullableFilter<"credit_s"> | string | null
    total_payment_acumulation?: FloatNullableFilter<"credit_s"> | number | null
    credit_state?: StringNullableFilter<"credit_s"> | string | null
    account_s?: XOR<Account_sNullableScalarRelationFilter, account_sWhereInput> | null
    client_s?: XOR<Client_sNullableScalarRelationFilter, client_sWhereInput> | null
    payment_s?: Payment_sListRelationFilter
  }

  export type credit_sOrderByWithRelationInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrderInput | SortOrder
    id_client_credit?: SortOrderInput | SortOrder
    price_to_sale?: SortOrderInput | SortOrder
    price_to_real_product?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    total_payment_acumulation?: SortOrderInput | SortOrder
    credit_state?: SortOrderInput | SortOrder
    account_s?: account_sOrderByWithRelationInput
    client_s?: client_sOrderByWithRelationInput
    payment_s?: payment_sOrderByRelationAggregateInput
  }

  export type credit_sWhereUniqueInput = Prisma.AtLeast<{
    id_credit?: number
    AND?: credit_sWhereInput | credit_sWhereInput[]
    OR?: credit_sWhereInput[]
    NOT?: credit_sWhereInput | credit_sWhereInput[]
    id_account_credit?: IntNullableFilter<"credit_s"> | number | null
    id_client_credit?: IntNullableFilter<"credit_s"> | number | null
    price_to_sale?: FloatNullableFilter<"credit_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"credit_s"> | number | null
    product_name?: StringNullableFilter<"credit_s"> | string | null
    total_payment_acumulation?: FloatNullableFilter<"credit_s"> | number | null
    credit_state?: StringNullableFilter<"credit_s"> | string | null
    account_s?: XOR<Account_sNullableScalarRelationFilter, account_sWhereInput> | null
    client_s?: XOR<Client_sNullableScalarRelationFilter, client_sWhereInput> | null
    payment_s?: Payment_sListRelationFilter
  }, "id_credit">

  export type credit_sOrderByWithAggregationInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrderInput | SortOrder
    id_client_credit?: SortOrderInput | SortOrder
    price_to_sale?: SortOrderInput | SortOrder
    price_to_real_product?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    total_payment_acumulation?: SortOrderInput | SortOrder
    credit_state?: SortOrderInput | SortOrder
    _count?: credit_sCountOrderByAggregateInput
    _avg?: credit_sAvgOrderByAggregateInput
    _max?: credit_sMaxOrderByAggregateInput
    _min?: credit_sMinOrderByAggregateInput
    _sum?: credit_sSumOrderByAggregateInput
  }

  export type credit_sScalarWhereWithAggregatesInput = {
    AND?: credit_sScalarWhereWithAggregatesInput | credit_sScalarWhereWithAggregatesInput[]
    OR?: credit_sScalarWhereWithAggregatesInput[]
    NOT?: credit_sScalarWhereWithAggregatesInput | credit_sScalarWhereWithAggregatesInput[]
    id_credit?: IntWithAggregatesFilter<"credit_s"> | number
    id_account_credit?: IntNullableWithAggregatesFilter<"credit_s"> | number | null
    id_client_credit?: IntNullableWithAggregatesFilter<"credit_s"> | number | null
    price_to_sale?: FloatNullableWithAggregatesFilter<"credit_s"> | number | null
    price_to_real_product?: FloatNullableWithAggregatesFilter<"credit_s"> | number | null
    product_name?: StringNullableWithAggregatesFilter<"credit_s"> | string | null
    total_payment_acumulation?: FloatNullableWithAggregatesFilter<"credit_s"> | number | null
    credit_state?: StringNullableWithAggregatesFilter<"credit_s"> | string | null
  }

  export type payment_sWhereInput = {
    AND?: payment_sWhereInput | payment_sWhereInput[]
    OR?: payment_sWhereInput[]
    NOT?: payment_sWhereInput | payment_sWhereInput[]
    id_payment?: IntFilter<"payment_s"> | number
    id_credit_payment?: IntNullableFilter<"payment_s"> | number | null
    payment?: FloatNullableFilter<"payment_s"> | number | null
    credit_s?: XOR<Credit_sNullableScalarRelationFilter, credit_sWhereInput> | null
  }

  export type payment_sOrderByWithRelationInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrderInput | SortOrder
    payment?: SortOrderInput | SortOrder
    credit_s?: credit_sOrderByWithRelationInput
  }

  export type payment_sWhereUniqueInput = Prisma.AtLeast<{
    id_payment?: number
    AND?: payment_sWhereInput | payment_sWhereInput[]
    OR?: payment_sWhereInput[]
    NOT?: payment_sWhereInput | payment_sWhereInput[]
    id_credit_payment?: IntNullableFilter<"payment_s"> | number | null
    payment?: FloatNullableFilter<"payment_s"> | number | null
    credit_s?: XOR<Credit_sNullableScalarRelationFilter, credit_sWhereInput> | null
  }, "id_payment">

  export type payment_sOrderByWithAggregationInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrderInput | SortOrder
    payment?: SortOrderInput | SortOrder
    _count?: payment_sCountOrderByAggregateInput
    _avg?: payment_sAvgOrderByAggregateInput
    _max?: payment_sMaxOrderByAggregateInput
    _min?: payment_sMinOrderByAggregateInput
    _sum?: payment_sSumOrderByAggregateInput
  }

  export type payment_sScalarWhereWithAggregatesInput = {
    AND?: payment_sScalarWhereWithAggregatesInput | payment_sScalarWhereWithAggregatesInput[]
    OR?: payment_sScalarWhereWithAggregatesInput[]
    NOT?: payment_sScalarWhereWithAggregatesInput | payment_sScalarWhereWithAggregatesInput[]
    id_payment?: IntWithAggregatesFilter<"payment_s"> | number
    id_credit_payment?: IntNullableWithAggregatesFilter<"payment_s"> | number | null
    payment?: FloatNullableWithAggregatesFilter<"payment_s"> | number | null
  }

  export type sale_sWhereInput = {
    AND?: sale_sWhereInput | sale_sWhereInput[]
    OR?: sale_sWhereInput[]
    NOT?: sale_sWhereInput | sale_sWhereInput[]
    id_sale?: IntFilter<"sale_s"> | number
    id_account_sale?: IntNullableFilter<"sale_s"> | number | null
    id_client_sale?: IntNullableFilter<"sale_s"> | number | null
    price_to_sale?: FloatNullableFilter<"sale_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"sale_s"> | number | null
    product_name?: StringNullableFilter<"sale_s"> | string | null
    account_s?: XOR<Account_sNullableScalarRelationFilter, account_sWhereInput> | null
    client_s?: XOR<Client_sNullableScalarRelationFilter, client_sWhereInput> | null
  }

  export type sale_sOrderByWithRelationInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrderInput | SortOrder
    id_client_sale?: SortOrderInput | SortOrder
    price_to_sale?: SortOrderInput | SortOrder
    price_to_real_product?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    account_s?: account_sOrderByWithRelationInput
    client_s?: client_sOrderByWithRelationInput
  }

  export type sale_sWhereUniqueInput = Prisma.AtLeast<{
    id_sale?: number
    AND?: sale_sWhereInput | sale_sWhereInput[]
    OR?: sale_sWhereInput[]
    NOT?: sale_sWhereInput | sale_sWhereInput[]
    id_account_sale?: IntNullableFilter<"sale_s"> | number | null
    id_client_sale?: IntNullableFilter<"sale_s"> | number | null
    price_to_sale?: FloatNullableFilter<"sale_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"sale_s"> | number | null
    product_name?: StringNullableFilter<"sale_s"> | string | null
    account_s?: XOR<Account_sNullableScalarRelationFilter, account_sWhereInput> | null
    client_s?: XOR<Client_sNullableScalarRelationFilter, client_sWhereInput> | null
  }, "id_sale">

  export type sale_sOrderByWithAggregationInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrderInput | SortOrder
    id_client_sale?: SortOrderInput | SortOrder
    price_to_sale?: SortOrderInput | SortOrder
    price_to_real_product?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    _count?: sale_sCountOrderByAggregateInput
    _avg?: sale_sAvgOrderByAggregateInput
    _max?: sale_sMaxOrderByAggregateInput
    _min?: sale_sMinOrderByAggregateInput
    _sum?: sale_sSumOrderByAggregateInput
  }

  export type sale_sScalarWhereWithAggregatesInput = {
    AND?: sale_sScalarWhereWithAggregatesInput | sale_sScalarWhereWithAggregatesInput[]
    OR?: sale_sScalarWhereWithAggregatesInput[]
    NOT?: sale_sScalarWhereWithAggregatesInput | sale_sScalarWhereWithAggregatesInput[]
    id_sale?: IntWithAggregatesFilter<"sale_s"> | number
    id_account_sale?: IntNullableWithAggregatesFilter<"sale_s"> | number | null
    id_client_sale?: IntNullableWithAggregatesFilter<"sale_s"> | number | null
    price_to_sale?: FloatNullableWithAggregatesFilter<"sale_s"> | number | null
    price_to_real_product?: FloatNullableWithAggregatesFilter<"sale_s"> | number | null
    product_name?: StringNullableWithAggregatesFilter<"sale_s"> | string | null
  }

  export type user_sWhereInput = {
    AND?: user_sWhereInput | user_sWhereInput[]
    OR?: user_sWhereInput[]
    NOT?: user_sWhereInput | user_sWhereInput[]
    id_user?: IntFilter<"user_s"> | number
    name_user?: StringNullableFilter<"user_s"> | string | null
    first_last_name?: StringNullableFilter<"user_s"> | string | null
    second_last_name?: StringNullableFilter<"user_s"> | string | null
    account_s?: Account_sListRelationFilter
  }

  export type user_sOrderByWithRelationInput = {
    id_user?: SortOrder
    name_user?: SortOrderInput | SortOrder
    first_last_name?: SortOrderInput | SortOrder
    second_last_name?: SortOrderInput | SortOrder
    account_s?: account_sOrderByRelationAggregateInput
  }

  export type user_sWhereUniqueInput = Prisma.AtLeast<{
    id_user?: number
    AND?: user_sWhereInput | user_sWhereInput[]
    OR?: user_sWhereInput[]
    NOT?: user_sWhereInput | user_sWhereInput[]
    name_user?: StringNullableFilter<"user_s"> | string | null
    first_last_name?: StringNullableFilter<"user_s"> | string | null
    second_last_name?: StringNullableFilter<"user_s"> | string | null
    account_s?: Account_sListRelationFilter
  }, "id_user">

  export type user_sOrderByWithAggregationInput = {
    id_user?: SortOrder
    name_user?: SortOrderInput | SortOrder
    first_last_name?: SortOrderInput | SortOrder
    second_last_name?: SortOrderInput | SortOrder
    _count?: user_sCountOrderByAggregateInput
    _avg?: user_sAvgOrderByAggregateInput
    _max?: user_sMaxOrderByAggregateInput
    _min?: user_sMinOrderByAggregateInput
    _sum?: user_sSumOrderByAggregateInput
  }

  export type user_sScalarWhereWithAggregatesInput = {
    AND?: user_sScalarWhereWithAggregatesInput | user_sScalarWhereWithAggregatesInput[]
    OR?: user_sScalarWhereWithAggregatesInput[]
    NOT?: user_sScalarWhereWithAggregatesInput | user_sScalarWhereWithAggregatesInput[]
    id_user?: IntWithAggregatesFilter<"user_s"> | number
    name_user?: StringNullableWithAggregatesFilter<"user_s"> | string | null
    first_last_name?: StringNullableWithAggregatesFilter<"user_s"> | string | null
    second_last_name?: StringNullableWithAggregatesFilter<"user_s"> | string | null
  }

  export type account_sCreateInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    user_s?: user_sCreateNestedOneWithoutAccount_sInput
    credit_s?: credit_sCreateNestedManyWithoutAccount_sInput
    sale_s?: sale_sCreateNestedManyWithoutAccount_sInput
  }

  export type account_sUncheckedCreateInput = {
    id_account: number
    id_user_account?: number | null
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    credit_s?: credit_sUncheckedCreateNestedManyWithoutAccount_sInput
    sale_s?: sale_sUncheckedCreateNestedManyWithoutAccount_sInput
  }

  export type account_sUpdateInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    user_s?: user_sUpdateOneWithoutAccount_sNestedInput
    credit_s?: credit_sUpdateManyWithoutAccount_sNestedInput
    sale_s?: sale_sUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sUncheckedUpdateInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    id_user_account?: NullableIntFieldUpdateOperationsInput | number | null
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUncheckedUpdateManyWithoutAccount_sNestedInput
    sale_s?: sale_sUncheckedUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sCreateManyInput = {
    id_account: number
    id_user_account?: number | null
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
  }

  export type account_sUpdateManyMutationInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type account_sUncheckedUpdateManyInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    id_user_account?: NullableIntFieldUpdateOperationsInput | number | null
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type client_sCreateInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    credit_s?: credit_sCreateNestedManyWithoutClient_sInput
    sale_s?: sale_sCreateNestedManyWithoutClient_sInput
  }

  export type client_sUncheckedCreateInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    credit_s?: credit_sUncheckedCreateNestedManyWithoutClient_sInput
    sale_s?: sale_sUncheckedCreateNestedManyWithoutClient_sInput
  }

  export type client_sUpdateInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUpdateManyWithoutClient_sNestedInput
    sale_s?: sale_sUpdateManyWithoutClient_sNestedInput
  }

  export type client_sUncheckedUpdateInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUncheckedUpdateManyWithoutClient_sNestedInput
    sale_s?: sale_sUncheckedUpdateManyWithoutClient_sNestedInput
  }

  export type client_sCreateManyInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
  }

  export type client_sUpdateManyMutationInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type client_sUncheckedUpdateManyInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type credit_sCreateInput = {
    id_credit: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    account_s?: account_sCreateNestedOneWithoutCredit_sInput
    client_s?: client_sCreateNestedOneWithoutCredit_sInput
    payment_s?: payment_sCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sUncheckedCreateInput = {
    id_credit: number
    id_account_credit?: number | null
    id_client_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    payment_s?: payment_sUncheckedCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sUpdateInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateOneWithoutCredit_sNestedInput
    client_s?: client_sUpdateOneWithoutCredit_sNestedInput
    payment_s?: payment_sUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_account_credit?: NullableIntFieldUpdateOperationsInput | number | null
    id_client_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    payment_s?: payment_sUncheckedUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sCreateManyInput = {
    id_credit: number
    id_account_credit?: number | null
    id_client_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
  }

  export type credit_sUpdateManyMutationInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credit_sUncheckedUpdateManyInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_account_credit?: NullableIntFieldUpdateOperationsInput | number | null
    id_client_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_sCreateInput = {
    id_payment: number
    payment?: number | null
    credit_s?: credit_sCreateNestedOneWithoutPayment_sInput
  }

  export type payment_sUncheckedCreateInput = {
    id_payment: number
    id_credit_payment?: number | null
    payment?: number | null
  }

  export type payment_sUpdateInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUpdateOneWithoutPayment_sNestedInput
  }

  export type payment_sUncheckedUpdateInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    id_credit_payment?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type payment_sCreateManyInput = {
    id_payment: number
    id_credit_payment?: number | null
    payment?: number | null
  }

  export type payment_sUpdateManyMutationInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type payment_sUncheckedUpdateManyInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    id_credit_payment?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sale_sCreateInput = {
    id_sale: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    account_s?: account_sCreateNestedOneWithoutSale_sInput
    client_s?: client_sCreateNestedOneWithoutSale_sInput
  }

  export type sale_sUncheckedCreateInput = {
    id_sale: number
    id_account_sale?: number | null
    id_client_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type sale_sUpdateInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateOneWithoutSale_sNestedInput
    client_s?: client_sUpdateOneWithoutSale_sNestedInput
  }

  export type sale_sUncheckedUpdateInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_account_sale?: NullableIntFieldUpdateOperationsInput | number | null
    id_client_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sCreateManyInput = {
    id_sale: number
    id_account_sale?: number | null
    id_client_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type sale_sUpdateManyMutationInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sUncheckedUpdateManyInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_account_sale?: NullableIntFieldUpdateOperationsInput | number | null
    id_client_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_sCreateInput = {
    id_user: number
    name_user?: string | null
    first_last_name?: string | null
    second_last_name?: string | null
    account_s?: account_sCreateNestedManyWithoutUser_sInput
  }

  export type user_sUncheckedCreateInput = {
    id_user: number
    name_user?: string | null
    first_last_name?: string | null
    second_last_name?: string | null
    account_s?: account_sUncheckedCreateNestedManyWithoutUser_sInput
  }

  export type user_sUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateManyWithoutUser_sNestedInput
  }

  export type user_sUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUncheckedUpdateManyWithoutUser_sNestedInput
  }

  export type user_sCreateManyInput = {
    id_user: number
    name_user?: string | null
    first_last_name?: string | null
    second_last_name?: string | null
  }

  export type user_sUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_sUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type User_sNullableScalarRelationFilter = {
    is?: user_sWhereInput | null
    isNot?: user_sWhereInput | null
  }

  export type Credit_sListRelationFilter = {
    every?: credit_sWhereInput
    some?: credit_sWhereInput
    none?: credit_sWhereInput
  }

  export type Sale_sListRelationFilter = {
    every?: sale_sWhereInput
    some?: sale_sWhereInput
    none?: sale_sWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type credit_sOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sale_sOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type account_sCountOrderByAggregateInput = {
    id_account?: SortOrder
    id_user_account?: SortOrder
    e_mail?: SortOrder
    password_?: SortOrder
    name_company?: SortOrder
    general_valance_account?: SortOrder
  }

  export type account_sAvgOrderByAggregateInput = {
    id_account?: SortOrder
    id_user_account?: SortOrder
    general_valance_account?: SortOrder
  }

  export type account_sMaxOrderByAggregateInput = {
    id_account?: SortOrder
    id_user_account?: SortOrder
    e_mail?: SortOrder
    password_?: SortOrder
    name_company?: SortOrder
    general_valance_account?: SortOrder
  }

  export type account_sMinOrderByAggregateInput = {
    id_account?: SortOrder
    id_user_account?: SortOrder
    e_mail?: SortOrder
    password_?: SortOrder
    name_company?: SortOrder
    general_valance_account?: SortOrder
  }

  export type account_sSumOrderByAggregateInput = {
    id_account?: SortOrder
    id_user_account?: SortOrder
    general_valance_account?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type client_sCountOrderByAggregateInput = {
    id_client?: SortOrder
    id_account_client?: SortOrder
    address_client?: SortOrder
    name_client?: SortOrder
    valance_credit_client?: SortOrder
  }

  export type client_sAvgOrderByAggregateInput = {
    id_client?: SortOrder
    id_account_client?: SortOrder
    valance_credit_client?: SortOrder
  }

  export type client_sMaxOrderByAggregateInput = {
    id_client?: SortOrder
    id_account_client?: SortOrder
    address_client?: SortOrder
    name_client?: SortOrder
    valance_credit_client?: SortOrder
  }

  export type client_sMinOrderByAggregateInput = {
    id_client?: SortOrder
    id_account_client?: SortOrder
    address_client?: SortOrder
    name_client?: SortOrder
    valance_credit_client?: SortOrder
  }

  export type client_sSumOrderByAggregateInput = {
    id_client?: SortOrder
    id_account_client?: SortOrder
    valance_credit_client?: SortOrder
  }

  export type Account_sNullableScalarRelationFilter = {
    is?: account_sWhereInput | null
    isNot?: account_sWhereInput | null
  }

  export type Client_sNullableScalarRelationFilter = {
    is?: client_sWhereInput | null
    isNot?: client_sWhereInput | null
  }

  export type Payment_sListRelationFilter = {
    every?: payment_sWhereInput
    some?: payment_sWhereInput
    none?: payment_sWhereInput
  }

  export type payment_sOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type credit_sCountOrderByAggregateInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrder
    id_client_credit?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
    total_payment_acumulation?: SortOrder
    credit_state?: SortOrder
  }

  export type credit_sAvgOrderByAggregateInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrder
    id_client_credit?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    total_payment_acumulation?: SortOrder
  }

  export type credit_sMaxOrderByAggregateInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrder
    id_client_credit?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
    total_payment_acumulation?: SortOrder
    credit_state?: SortOrder
  }

  export type credit_sMinOrderByAggregateInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrder
    id_client_credit?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
    total_payment_acumulation?: SortOrder
    credit_state?: SortOrder
  }

  export type credit_sSumOrderByAggregateInput = {
    id_credit?: SortOrder
    id_account_credit?: SortOrder
    id_client_credit?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    total_payment_acumulation?: SortOrder
  }

  export type Credit_sNullableScalarRelationFilter = {
    is?: credit_sWhereInput | null
    isNot?: credit_sWhereInput | null
  }

  export type payment_sCountOrderByAggregateInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrder
    payment?: SortOrder
  }

  export type payment_sAvgOrderByAggregateInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrder
    payment?: SortOrder
  }

  export type payment_sMaxOrderByAggregateInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrder
    payment?: SortOrder
  }

  export type payment_sMinOrderByAggregateInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrder
    payment?: SortOrder
  }

  export type payment_sSumOrderByAggregateInput = {
    id_payment?: SortOrder
    id_credit_payment?: SortOrder
    payment?: SortOrder
  }

  export type sale_sCountOrderByAggregateInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrder
    id_client_sale?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
  }

  export type sale_sAvgOrderByAggregateInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrder
    id_client_sale?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
  }

  export type sale_sMaxOrderByAggregateInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrder
    id_client_sale?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
  }

  export type sale_sMinOrderByAggregateInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrder
    id_client_sale?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
    product_name?: SortOrder
  }

  export type sale_sSumOrderByAggregateInput = {
    id_sale?: SortOrder
    id_account_sale?: SortOrder
    id_client_sale?: SortOrder
    price_to_sale?: SortOrder
    price_to_real_product?: SortOrder
  }

  export type Account_sListRelationFilter = {
    every?: account_sWhereInput
    some?: account_sWhereInput
    none?: account_sWhereInput
  }

  export type account_sOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_sCountOrderByAggregateInput = {
    id_user?: SortOrder
    name_user?: SortOrder
    first_last_name?: SortOrder
    second_last_name?: SortOrder
  }

  export type user_sAvgOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type user_sMaxOrderByAggregateInput = {
    id_user?: SortOrder
    name_user?: SortOrder
    first_last_name?: SortOrder
    second_last_name?: SortOrder
  }

  export type user_sMinOrderByAggregateInput = {
    id_user?: SortOrder
    name_user?: SortOrder
    first_last_name?: SortOrder
    second_last_name?: SortOrder
  }

  export type user_sSumOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type user_sCreateNestedOneWithoutAccount_sInput = {
    create?: XOR<user_sCreateWithoutAccount_sInput, user_sUncheckedCreateWithoutAccount_sInput>
    connectOrCreate?: user_sCreateOrConnectWithoutAccount_sInput
    connect?: user_sWhereUniqueInput
  }

  export type credit_sCreateNestedManyWithoutAccount_sInput = {
    create?: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput> | credit_sCreateWithoutAccount_sInput[] | credit_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutAccount_sInput | credit_sCreateOrConnectWithoutAccount_sInput[]
    createMany?: credit_sCreateManyAccount_sInputEnvelope
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
  }

  export type sale_sCreateNestedManyWithoutAccount_sInput = {
    create?: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput> | sale_sCreateWithoutAccount_sInput[] | sale_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutAccount_sInput | sale_sCreateOrConnectWithoutAccount_sInput[]
    createMany?: sale_sCreateManyAccount_sInputEnvelope
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
  }

  export type credit_sUncheckedCreateNestedManyWithoutAccount_sInput = {
    create?: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput> | credit_sCreateWithoutAccount_sInput[] | credit_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutAccount_sInput | credit_sCreateOrConnectWithoutAccount_sInput[]
    createMany?: credit_sCreateManyAccount_sInputEnvelope
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
  }

  export type sale_sUncheckedCreateNestedManyWithoutAccount_sInput = {
    create?: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput> | sale_sCreateWithoutAccount_sInput[] | sale_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutAccount_sInput | sale_sCreateOrConnectWithoutAccount_sInput[]
    createMany?: sale_sCreateManyAccount_sInputEnvelope
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_sUpdateOneWithoutAccount_sNestedInput = {
    create?: XOR<user_sCreateWithoutAccount_sInput, user_sUncheckedCreateWithoutAccount_sInput>
    connectOrCreate?: user_sCreateOrConnectWithoutAccount_sInput
    upsert?: user_sUpsertWithoutAccount_sInput
    disconnect?: user_sWhereInput | boolean
    delete?: user_sWhereInput | boolean
    connect?: user_sWhereUniqueInput
    update?: XOR<XOR<user_sUpdateToOneWithWhereWithoutAccount_sInput, user_sUpdateWithoutAccount_sInput>, user_sUncheckedUpdateWithoutAccount_sInput>
  }

  export type credit_sUpdateManyWithoutAccount_sNestedInput = {
    create?: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput> | credit_sCreateWithoutAccount_sInput[] | credit_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutAccount_sInput | credit_sCreateOrConnectWithoutAccount_sInput[]
    upsert?: credit_sUpsertWithWhereUniqueWithoutAccount_sInput | credit_sUpsertWithWhereUniqueWithoutAccount_sInput[]
    createMany?: credit_sCreateManyAccount_sInputEnvelope
    set?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    disconnect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    delete?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    update?: credit_sUpdateWithWhereUniqueWithoutAccount_sInput | credit_sUpdateWithWhereUniqueWithoutAccount_sInput[]
    updateMany?: credit_sUpdateManyWithWhereWithoutAccount_sInput | credit_sUpdateManyWithWhereWithoutAccount_sInput[]
    deleteMany?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
  }

  export type sale_sUpdateManyWithoutAccount_sNestedInput = {
    create?: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput> | sale_sCreateWithoutAccount_sInput[] | sale_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutAccount_sInput | sale_sCreateOrConnectWithoutAccount_sInput[]
    upsert?: sale_sUpsertWithWhereUniqueWithoutAccount_sInput | sale_sUpsertWithWhereUniqueWithoutAccount_sInput[]
    createMany?: sale_sCreateManyAccount_sInputEnvelope
    set?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    disconnect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    delete?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    update?: sale_sUpdateWithWhereUniqueWithoutAccount_sInput | sale_sUpdateWithWhereUniqueWithoutAccount_sInput[]
    updateMany?: sale_sUpdateManyWithWhereWithoutAccount_sInput | sale_sUpdateManyWithWhereWithoutAccount_sInput[]
    deleteMany?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type credit_sUncheckedUpdateManyWithoutAccount_sNestedInput = {
    create?: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput> | credit_sCreateWithoutAccount_sInput[] | credit_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutAccount_sInput | credit_sCreateOrConnectWithoutAccount_sInput[]
    upsert?: credit_sUpsertWithWhereUniqueWithoutAccount_sInput | credit_sUpsertWithWhereUniqueWithoutAccount_sInput[]
    createMany?: credit_sCreateManyAccount_sInputEnvelope
    set?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    disconnect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    delete?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    update?: credit_sUpdateWithWhereUniqueWithoutAccount_sInput | credit_sUpdateWithWhereUniqueWithoutAccount_sInput[]
    updateMany?: credit_sUpdateManyWithWhereWithoutAccount_sInput | credit_sUpdateManyWithWhereWithoutAccount_sInput[]
    deleteMany?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
  }

  export type sale_sUncheckedUpdateManyWithoutAccount_sNestedInput = {
    create?: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput> | sale_sCreateWithoutAccount_sInput[] | sale_sUncheckedCreateWithoutAccount_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutAccount_sInput | sale_sCreateOrConnectWithoutAccount_sInput[]
    upsert?: sale_sUpsertWithWhereUniqueWithoutAccount_sInput | sale_sUpsertWithWhereUniqueWithoutAccount_sInput[]
    createMany?: sale_sCreateManyAccount_sInputEnvelope
    set?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    disconnect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    delete?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    update?: sale_sUpdateWithWhereUniqueWithoutAccount_sInput | sale_sUpdateWithWhereUniqueWithoutAccount_sInput[]
    updateMany?: sale_sUpdateManyWithWhereWithoutAccount_sInput | sale_sUpdateManyWithWhereWithoutAccount_sInput[]
    deleteMany?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
  }

  export type credit_sCreateNestedManyWithoutClient_sInput = {
    create?: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput> | credit_sCreateWithoutClient_sInput[] | credit_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutClient_sInput | credit_sCreateOrConnectWithoutClient_sInput[]
    createMany?: credit_sCreateManyClient_sInputEnvelope
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
  }

  export type sale_sCreateNestedManyWithoutClient_sInput = {
    create?: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput> | sale_sCreateWithoutClient_sInput[] | sale_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutClient_sInput | sale_sCreateOrConnectWithoutClient_sInput[]
    createMany?: sale_sCreateManyClient_sInputEnvelope
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
  }

  export type credit_sUncheckedCreateNestedManyWithoutClient_sInput = {
    create?: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput> | credit_sCreateWithoutClient_sInput[] | credit_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutClient_sInput | credit_sCreateOrConnectWithoutClient_sInput[]
    createMany?: credit_sCreateManyClient_sInputEnvelope
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
  }

  export type sale_sUncheckedCreateNestedManyWithoutClient_sInput = {
    create?: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput> | sale_sCreateWithoutClient_sInput[] | sale_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutClient_sInput | sale_sCreateOrConnectWithoutClient_sInput[]
    createMany?: sale_sCreateManyClient_sInputEnvelope
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
  }

  export type credit_sUpdateManyWithoutClient_sNestedInput = {
    create?: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput> | credit_sCreateWithoutClient_sInput[] | credit_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutClient_sInput | credit_sCreateOrConnectWithoutClient_sInput[]
    upsert?: credit_sUpsertWithWhereUniqueWithoutClient_sInput | credit_sUpsertWithWhereUniqueWithoutClient_sInput[]
    createMany?: credit_sCreateManyClient_sInputEnvelope
    set?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    disconnect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    delete?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    update?: credit_sUpdateWithWhereUniqueWithoutClient_sInput | credit_sUpdateWithWhereUniqueWithoutClient_sInput[]
    updateMany?: credit_sUpdateManyWithWhereWithoutClient_sInput | credit_sUpdateManyWithWhereWithoutClient_sInput[]
    deleteMany?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
  }

  export type sale_sUpdateManyWithoutClient_sNestedInput = {
    create?: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput> | sale_sCreateWithoutClient_sInput[] | sale_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutClient_sInput | sale_sCreateOrConnectWithoutClient_sInput[]
    upsert?: sale_sUpsertWithWhereUniqueWithoutClient_sInput | sale_sUpsertWithWhereUniqueWithoutClient_sInput[]
    createMany?: sale_sCreateManyClient_sInputEnvelope
    set?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    disconnect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    delete?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    update?: sale_sUpdateWithWhereUniqueWithoutClient_sInput | sale_sUpdateWithWhereUniqueWithoutClient_sInput[]
    updateMany?: sale_sUpdateManyWithWhereWithoutClient_sInput | sale_sUpdateManyWithWhereWithoutClient_sInput[]
    deleteMany?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
  }

  export type credit_sUncheckedUpdateManyWithoutClient_sNestedInput = {
    create?: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput> | credit_sCreateWithoutClient_sInput[] | credit_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: credit_sCreateOrConnectWithoutClient_sInput | credit_sCreateOrConnectWithoutClient_sInput[]
    upsert?: credit_sUpsertWithWhereUniqueWithoutClient_sInput | credit_sUpsertWithWhereUniqueWithoutClient_sInput[]
    createMany?: credit_sCreateManyClient_sInputEnvelope
    set?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    disconnect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    delete?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    connect?: credit_sWhereUniqueInput | credit_sWhereUniqueInput[]
    update?: credit_sUpdateWithWhereUniqueWithoutClient_sInput | credit_sUpdateWithWhereUniqueWithoutClient_sInput[]
    updateMany?: credit_sUpdateManyWithWhereWithoutClient_sInput | credit_sUpdateManyWithWhereWithoutClient_sInput[]
    deleteMany?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
  }

  export type sale_sUncheckedUpdateManyWithoutClient_sNestedInput = {
    create?: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput> | sale_sCreateWithoutClient_sInput[] | sale_sUncheckedCreateWithoutClient_sInput[]
    connectOrCreate?: sale_sCreateOrConnectWithoutClient_sInput | sale_sCreateOrConnectWithoutClient_sInput[]
    upsert?: sale_sUpsertWithWhereUniqueWithoutClient_sInput | sale_sUpsertWithWhereUniqueWithoutClient_sInput[]
    createMany?: sale_sCreateManyClient_sInputEnvelope
    set?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    disconnect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    delete?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    connect?: sale_sWhereUniqueInput | sale_sWhereUniqueInput[]
    update?: sale_sUpdateWithWhereUniqueWithoutClient_sInput | sale_sUpdateWithWhereUniqueWithoutClient_sInput[]
    updateMany?: sale_sUpdateManyWithWhereWithoutClient_sInput | sale_sUpdateManyWithWhereWithoutClient_sInput[]
    deleteMany?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
  }

  export type account_sCreateNestedOneWithoutCredit_sInput = {
    create?: XOR<account_sCreateWithoutCredit_sInput, account_sUncheckedCreateWithoutCredit_sInput>
    connectOrCreate?: account_sCreateOrConnectWithoutCredit_sInput
    connect?: account_sWhereUniqueInput
  }

  export type client_sCreateNestedOneWithoutCredit_sInput = {
    create?: XOR<client_sCreateWithoutCredit_sInput, client_sUncheckedCreateWithoutCredit_sInput>
    connectOrCreate?: client_sCreateOrConnectWithoutCredit_sInput
    connect?: client_sWhereUniqueInput
  }

  export type payment_sCreateNestedManyWithoutCredit_sInput = {
    create?: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput> | payment_sCreateWithoutCredit_sInput[] | payment_sUncheckedCreateWithoutCredit_sInput[]
    connectOrCreate?: payment_sCreateOrConnectWithoutCredit_sInput | payment_sCreateOrConnectWithoutCredit_sInput[]
    createMany?: payment_sCreateManyCredit_sInputEnvelope
    connect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
  }

  export type payment_sUncheckedCreateNestedManyWithoutCredit_sInput = {
    create?: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput> | payment_sCreateWithoutCredit_sInput[] | payment_sUncheckedCreateWithoutCredit_sInput[]
    connectOrCreate?: payment_sCreateOrConnectWithoutCredit_sInput | payment_sCreateOrConnectWithoutCredit_sInput[]
    createMany?: payment_sCreateManyCredit_sInputEnvelope
    connect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
  }

  export type account_sUpdateOneWithoutCredit_sNestedInput = {
    create?: XOR<account_sCreateWithoutCredit_sInput, account_sUncheckedCreateWithoutCredit_sInput>
    connectOrCreate?: account_sCreateOrConnectWithoutCredit_sInput
    upsert?: account_sUpsertWithoutCredit_sInput
    disconnect?: account_sWhereInput | boolean
    delete?: account_sWhereInput | boolean
    connect?: account_sWhereUniqueInput
    update?: XOR<XOR<account_sUpdateToOneWithWhereWithoutCredit_sInput, account_sUpdateWithoutCredit_sInput>, account_sUncheckedUpdateWithoutCredit_sInput>
  }

  export type client_sUpdateOneWithoutCredit_sNestedInput = {
    create?: XOR<client_sCreateWithoutCredit_sInput, client_sUncheckedCreateWithoutCredit_sInput>
    connectOrCreate?: client_sCreateOrConnectWithoutCredit_sInput
    upsert?: client_sUpsertWithoutCredit_sInput
    disconnect?: client_sWhereInput | boolean
    delete?: client_sWhereInput | boolean
    connect?: client_sWhereUniqueInput
    update?: XOR<XOR<client_sUpdateToOneWithWhereWithoutCredit_sInput, client_sUpdateWithoutCredit_sInput>, client_sUncheckedUpdateWithoutCredit_sInput>
  }

  export type payment_sUpdateManyWithoutCredit_sNestedInput = {
    create?: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput> | payment_sCreateWithoutCredit_sInput[] | payment_sUncheckedCreateWithoutCredit_sInput[]
    connectOrCreate?: payment_sCreateOrConnectWithoutCredit_sInput | payment_sCreateOrConnectWithoutCredit_sInput[]
    upsert?: payment_sUpsertWithWhereUniqueWithoutCredit_sInput | payment_sUpsertWithWhereUniqueWithoutCredit_sInput[]
    createMany?: payment_sCreateManyCredit_sInputEnvelope
    set?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    disconnect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    delete?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    connect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    update?: payment_sUpdateWithWhereUniqueWithoutCredit_sInput | payment_sUpdateWithWhereUniqueWithoutCredit_sInput[]
    updateMany?: payment_sUpdateManyWithWhereWithoutCredit_sInput | payment_sUpdateManyWithWhereWithoutCredit_sInput[]
    deleteMany?: payment_sScalarWhereInput | payment_sScalarWhereInput[]
  }

  export type payment_sUncheckedUpdateManyWithoutCredit_sNestedInput = {
    create?: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput> | payment_sCreateWithoutCredit_sInput[] | payment_sUncheckedCreateWithoutCredit_sInput[]
    connectOrCreate?: payment_sCreateOrConnectWithoutCredit_sInput | payment_sCreateOrConnectWithoutCredit_sInput[]
    upsert?: payment_sUpsertWithWhereUniqueWithoutCredit_sInput | payment_sUpsertWithWhereUniqueWithoutCredit_sInput[]
    createMany?: payment_sCreateManyCredit_sInputEnvelope
    set?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    disconnect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    delete?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    connect?: payment_sWhereUniqueInput | payment_sWhereUniqueInput[]
    update?: payment_sUpdateWithWhereUniqueWithoutCredit_sInput | payment_sUpdateWithWhereUniqueWithoutCredit_sInput[]
    updateMany?: payment_sUpdateManyWithWhereWithoutCredit_sInput | payment_sUpdateManyWithWhereWithoutCredit_sInput[]
    deleteMany?: payment_sScalarWhereInput | payment_sScalarWhereInput[]
  }

  export type credit_sCreateNestedOneWithoutPayment_sInput = {
    create?: XOR<credit_sCreateWithoutPayment_sInput, credit_sUncheckedCreateWithoutPayment_sInput>
    connectOrCreate?: credit_sCreateOrConnectWithoutPayment_sInput
    connect?: credit_sWhereUniqueInput
  }

  export type credit_sUpdateOneWithoutPayment_sNestedInput = {
    create?: XOR<credit_sCreateWithoutPayment_sInput, credit_sUncheckedCreateWithoutPayment_sInput>
    connectOrCreate?: credit_sCreateOrConnectWithoutPayment_sInput
    upsert?: credit_sUpsertWithoutPayment_sInput
    disconnect?: credit_sWhereInput | boolean
    delete?: credit_sWhereInput | boolean
    connect?: credit_sWhereUniqueInput
    update?: XOR<XOR<credit_sUpdateToOneWithWhereWithoutPayment_sInput, credit_sUpdateWithoutPayment_sInput>, credit_sUncheckedUpdateWithoutPayment_sInput>
  }

  export type account_sCreateNestedOneWithoutSale_sInput = {
    create?: XOR<account_sCreateWithoutSale_sInput, account_sUncheckedCreateWithoutSale_sInput>
    connectOrCreate?: account_sCreateOrConnectWithoutSale_sInput
    connect?: account_sWhereUniqueInput
  }

  export type client_sCreateNestedOneWithoutSale_sInput = {
    create?: XOR<client_sCreateWithoutSale_sInput, client_sUncheckedCreateWithoutSale_sInput>
    connectOrCreate?: client_sCreateOrConnectWithoutSale_sInput
    connect?: client_sWhereUniqueInput
  }

  export type account_sUpdateOneWithoutSale_sNestedInput = {
    create?: XOR<account_sCreateWithoutSale_sInput, account_sUncheckedCreateWithoutSale_sInput>
    connectOrCreate?: account_sCreateOrConnectWithoutSale_sInput
    upsert?: account_sUpsertWithoutSale_sInput
    disconnect?: account_sWhereInput | boolean
    delete?: account_sWhereInput | boolean
    connect?: account_sWhereUniqueInput
    update?: XOR<XOR<account_sUpdateToOneWithWhereWithoutSale_sInput, account_sUpdateWithoutSale_sInput>, account_sUncheckedUpdateWithoutSale_sInput>
  }

  export type client_sUpdateOneWithoutSale_sNestedInput = {
    create?: XOR<client_sCreateWithoutSale_sInput, client_sUncheckedCreateWithoutSale_sInput>
    connectOrCreate?: client_sCreateOrConnectWithoutSale_sInput
    upsert?: client_sUpsertWithoutSale_sInput
    disconnect?: client_sWhereInput | boolean
    delete?: client_sWhereInput | boolean
    connect?: client_sWhereUniqueInput
    update?: XOR<XOR<client_sUpdateToOneWithWhereWithoutSale_sInput, client_sUpdateWithoutSale_sInput>, client_sUncheckedUpdateWithoutSale_sInput>
  }

  export type account_sCreateNestedManyWithoutUser_sInput = {
    create?: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput> | account_sCreateWithoutUser_sInput[] | account_sUncheckedCreateWithoutUser_sInput[]
    connectOrCreate?: account_sCreateOrConnectWithoutUser_sInput | account_sCreateOrConnectWithoutUser_sInput[]
    createMany?: account_sCreateManyUser_sInputEnvelope
    connect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
  }

  export type account_sUncheckedCreateNestedManyWithoutUser_sInput = {
    create?: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput> | account_sCreateWithoutUser_sInput[] | account_sUncheckedCreateWithoutUser_sInput[]
    connectOrCreate?: account_sCreateOrConnectWithoutUser_sInput | account_sCreateOrConnectWithoutUser_sInput[]
    createMany?: account_sCreateManyUser_sInputEnvelope
    connect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
  }

  export type account_sUpdateManyWithoutUser_sNestedInput = {
    create?: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput> | account_sCreateWithoutUser_sInput[] | account_sUncheckedCreateWithoutUser_sInput[]
    connectOrCreate?: account_sCreateOrConnectWithoutUser_sInput | account_sCreateOrConnectWithoutUser_sInput[]
    upsert?: account_sUpsertWithWhereUniqueWithoutUser_sInput | account_sUpsertWithWhereUniqueWithoutUser_sInput[]
    createMany?: account_sCreateManyUser_sInputEnvelope
    set?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    disconnect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    delete?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    connect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    update?: account_sUpdateWithWhereUniqueWithoutUser_sInput | account_sUpdateWithWhereUniqueWithoutUser_sInput[]
    updateMany?: account_sUpdateManyWithWhereWithoutUser_sInput | account_sUpdateManyWithWhereWithoutUser_sInput[]
    deleteMany?: account_sScalarWhereInput | account_sScalarWhereInput[]
  }

  export type account_sUncheckedUpdateManyWithoutUser_sNestedInput = {
    create?: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput> | account_sCreateWithoutUser_sInput[] | account_sUncheckedCreateWithoutUser_sInput[]
    connectOrCreate?: account_sCreateOrConnectWithoutUser_sInput | account_sCreateOrConnectWithoutUser_sInput[]
    upsert?: account_sUpsertWithWhereUniqueWithoutUser_sInput | account_sUpsertWithWhereUniqueWithoutUser_sInput[]
    createMany?: account_sCreateManyUser_sInputEnvelope
    set?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    disconnect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    delete?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    connect?: account_sWhereUniqueInput | account_sWhereUniqueInput[]
    update?: account_sUpdateWithWhereUniqueWithoutUser_sInput | account_sUpdateWithWhereUniqueWithoutUser_sInput[]
    updateMany?: account_sUpdateManyWithWhereWithoutUser_sInput | account_sUpdateManyWithWhereWithoutUser_sInput[]
    deleteMany?: account_sScalarWhereInput | account_sScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type user_sCreateWithoutAccount_sInput = {
    id_user: number
    name_user?: string | null
    first_last_name?: string | null
    second_last_name?: string | null
  }

  export type user_sUncheckedCreateWithoutAccount_sInput = {
    id_user: number
    name_user?: string | null
    first_last_name?: string | null
    second_last_name?: string | null
  }

  export type user_sCreateOrConnectWithoutAccount_sInput = {
    where: user_sWhereUniqueInput
    create: XOR<user_sCreateWithoutAccount_sInput, user_sUncheckedCreateWithoutAccount_sInput>
  }

  export type credit_sCreateWithoutAccount_sInput = {
    id_credit: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    client_s?: client_sCreateNestedOneWithoutCredit_sInput
    payment_s?: payment_sCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sUncheckedCreateWithoutAccount_sInput = {
    id_credit: number
    id_client_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    payment_s?: payment_sUncheckedCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sCreateOrConnectWithoutAccount_sInput = {
    where: credit_sWhereUniqueInput
    create: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput>
  }

  export type credit_sCreateManyAccount_sInputEnvelope = {
    data: credit_sCreateManyAccount_sInput | credit_sCreateManyAccount_sInput[]
    skipDuplicates?: boolean
  }

  export type sale_sCreateWithoutAccount_sInput = {
    id_sale: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    client_s?: client_sCreateNestedOneWithoutSale_sInput
  }

  export type sale_sUncheckedCreateWithoutAccount_sInput = {
    id_sale: number
    id_client_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type sale_sCreateOrConnectWithoutAccount_sInput = {
    where: sale_sWhereUniqueInput
    create: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput>
  }

  export type sale_sCreateManyAccount_sInputEnvelope = {
    data: sale_sCreateManyAccount_sInput | sale_sCreateManyAccount_sInput[]
    skipDuplicates?: boolean
  }

  export type user_sUpsertWithoutAccount_sInput = {
    update: XOR<user_sUpdateWithoutAccount_sInput, user_sUncheckedUpdateWithoutAccount_sInput>
    create: XOR<user_sCreateWithoutAccount_sInput, user_sUncheckedCreateWithoutAccount_sInput>
    where?: user_sWhereInput
  }

  export type user_sUpdateToOneWithWhereWithoutAccount_sInput = {
    where?: user_sWhereInput
    data: XOR<user_sUpdateWithoutAccount_sInput, user_sUncheckedUpdateWithoutAccount_sInput>
  }

  export type user_sUpdateWithoutAccount_sInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_sUncheckedUpdateWithoutAccount_sInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    name_user?: NullableStringFieldUpdateOperationsInput | string | null
    first_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    second_last_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credit_sUpsertWithWhereUniqueWithoutAccount_sInput = {
    where: credit_sWhereUniqueInput
    update: XOR<credit_sUpdateWithoutAccount_sInput, credit_sUncheckedUpdateWithoutAccount_sInput>
    create: XOR<credit_sCreateWithoutAccount_sInput, credit_sUncheckedCreateWithoutAccount_sInput>
  }

  export type credit_sUpdateWithWhereUniqueWithoutAccount_sInput = {
    where: credit_sWhereUniqueInput
    data: XOR<credit_sUpdateWithoutAccount_sInput, credit_sUncheckedUpdateWithoutAccount_sInput>
  }

  export type credit_sUpdateManyWithWhereWithoutAccount_sInput = {
    where: credit_sScalarWhereInput
    data: XOR<credit_sUpdateManyMutationInput, credit_sUncheckedUpdateManyWithoutAccount_sInput>
  }

  export type credit_sScalarWhereInput = {
    AND?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
    OR?: credit_sScalarWhereInput[]
    NOT?: credit_sScalarWhereInput | credit_sScalarWhereInput[]
    id_credit?: IntFilter<"credit_s"> | number
    id_account_credit?: IntNullableFilter<"credit_s"> | number | null
    id_client_credit?: IntNullableFilter<"credit_s"> | number | null
    price_to_sale?: FloatNullableFilter<"credit_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"credit_s"> | number | null
    product_name?: StringNullableFilter<"credit_s"> | string | null
    total_payment_acumulation?: FloatNullableFilter<"credit_s"> | number | null
    credit_state?: StringNullableFilter<"credit_s"> | string | null
  }

  export type sale_sUpsertWithWhereUniqueWithoutAccount_sInput = {
    where: sale_sWhereUniqueInput
    update: XOR<sale_sUpdateWithoutAccount_sInput, sale_sUncheckedUpdateWithoutAccount_sInput>
    create: XOR<sale_sCreateWithoutAccount_sInput, sale_sUncheckedCreateWithoutAccount_sInput>
  }

  export type sale_sUpdateWithWhereUniqueWithoutAccount_sInput = {
    where: sale_sWhereUniqueInput
    data: XOR<sale_sUpdateWithoutAccount_sInput, sale_sUncheckedUpdateWithoutAccount_sInput>
  }

  export type sale_sUpdateManyWithWhereWithoutAccount_sInput = {
    where: sale_sScalarWhereInput
    data: XOR<sale_sUpdateManyMutationInput, sale_sUncheckedUpdateManyWithoutAccount_sInput>
  }

  export type sale_sScalarWhereInput = {
    AND?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
    OR?: sale_sScalarWhereInput[]
    NOT?: sale_sScalarWhereInput | sale_sScalarWhereInput[]
    id_sale?: IntFilter<"sale_s"> | number
    id_account_sale?: IntNullableFilter<"sale_s"> | number | null
    id_client_sale?: IntNullableFilter<"sale_s"> | number | null
    price_to_sale?: FloatNullableFilter<"sale_s"> | number | null
    price_to_real_product?: FloatNullableFilter<"sale_s"> | number | null
    product_name?: StringNullableFilter<"sale_s"> | string | null
  }

  export type credit_sCreateWithoutClient_sInput = {
    id_credit: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    account_s?: account_sCreateNestedOneWithoutCredit_sInput
    payment_s?: payment_sCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sUncheckedCreateWithoutClient_sInput = {
    id_credit: number
    id_account_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    payment_s?: payment_sUncheckedCreateNestedManyWithoutCredit_sInput
  }

  export type credit_sCreateOrConnectWithoutClient_sInput = {
    where: credit_sWhereUniqueInput
    create: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput>
  }

  export type credit_sCreateManyClient_sInputEnvelope = {
    data: credit_sCreateManyClient_sInput | credit_sCreateManyClient_sInput[]
    skipDuplicates?: boolean
  }

  export type sale_sCreateWithoutClient_sInput = {
    id_sale: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    account_s?: account_sCreateNestedOneWithoutSale_sInput
  }

  export type sale_sUncheckedCreateWithoutClient_sInput = {
    id_sale: number
    id_account_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type sale_sCreateOrConnectWithoutClient_sInput = {
    where: sale_sWhereUniqueInput
    create: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput>
  }

  export type sale_sCreateManyClient_sInputEnvelope = {
    data: sale_sCreateManyClient_sInput | sale_sCreateManyClient_sInput[]
    skipDuplicates?: boolean
  }

  export type credit_sUpsertWithWhereUniqueWithoutClient_sInput = {
    where: credit_sWhereUniqueInput
    update: XOR<credit_sUpdateWithoutClient_sInput, credit_sUncheckedUpdateWithoutClient_sInput>
    create: XOR<credit_sCreateWithoutClient_sInput, credit_sUncheckedCreateWithoutClient_sInput>
  }

  export type credit_sUpdateWithWhereUniqueWithoutClient_sInput = {
    where: credit_sWhereUniqueInput
    data: XOR<credit_sUpdateWithoutClient_sInput, credit_sUncheckedUpdateWithoutClient_sInput>
  }

  export type credit_sUpdateManyWithWhereWithoutClient_sInput = {
    where: credit_sScalarWhereInput
    data: XOR<credit_sUpdateManyMutationInput, credit_sUncheckedUpdateManyWithoutClient_sInput>
  }

  export type sale_sUpsertWithWhereUniqueWithoutClient_sInput = {
    where: sale_sWhereUniqueInput
    update: XOR<sale_sUpdateWithoutClient_sInput, sale_sUncheckedUpdateWithoutClient_sInput>
    create: XOR<sale_sCreateWithoutClient_sInput, sale_sUncheckedCreateWithoutClient_sInput>
  }

  export type sale_sUpdateWithWhereUniqueWithoutClient_sInput = {
    where: sale_sWhereUniqueInput
    data: XOR<sale_sUpdateWithoutClient_sInput, sale_sUncheckedUpdateWithoutClient_sInput>
  }

  export type sale_sUpdateManyWithWhereWithoutClient_sInput = {
    where: sale_sScalarWhereInput
    data: XOR<sale_sUpdateManyMutationInput, sale_sUncheckedUpdateManyWithoutClient_sInput>
  }

  export type account_sCreateWithoutCredit_sInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    user_s?: user_sCreateNestedOneWithoutAccount_sInput
    sale_s?: sale_sCreateNestedManyWithoutAccount_sInput
  }

  export type account_sUncheckedCreateWithoutCredit_sInput = {
    id_account: number
    id_user_account?: number | null
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    sale_s?: sale_sUncheckedCreateNestedManyWithoutAccount_sInput
  }

  export type account_sCreateOrConnectWithoutCredit_sInput = {
    where: account_sWhereUniqueInput
    create: XOR<account_sCreateWithoutCredit_sInput, account_sUncheckedCreateWithoutCredit_sInput>
  }

  export type client_sCreateWithoutCredit_sInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    sale_s?: sale_sCreateNestedManyWithoutClient_sInput
  }

  export type client_sUncheckedCreateWithoutCredit_sInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    sale_s?: sale_sUncheckedCreateNestedManyWithoutClient_sInput
  }

  export type client_sCreateOrConnectWithoutCredit_sInput = {
    where: client_sWhereUniqueInput
    create: XOR<client_sCreateWithoutCredit_sInput, client_sUncheckedCreateWithoutCredit_sInput>
  }

  export type payment_sCreateWithoutCredit_sInput = {
    id_payment: number
    payment?: number | null
  }

  export type payment_sUncheckedCreateWithoutCredit_sInput = {
    id_payment: number
    payment?: number | null
  }

  export type payment_sCreateOrConnectWithoutCredit_sInput = {
    where: payment_sWhereUniqueInput
    create: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput>
  }

  export type payment_sCreateManyCredit_sInputEnvelope = {
    data: payment_sCreateManyCredit_sInput | payment_sCreateManyCredit_sInput[]
    skipDuplicates?: boolean
  }

  export type account_sUpsertWithoutCredit_sInput = {
    update: XOR<account_sUpdateWithoutCredit_sInput, account_sUncheckedUpdateWithoutCredit_sInput>
    create: XOR<account_sCreateWithoutCredit_sInput, account_sUncheckedCreateWithoutCredit_sInput>
    where?: account_sWhereInput
  }

  export type account_sUpdateToOneWithWhereWithoutCredit_sInput = {
    where?: account_sWhereInput
    data: XOR<account_sUpdateWithoutCredit_sInput, account_sUncheckedUpdateWithoutCredit_sInput>
  }

  export type account_sUpdateWithoutCredit_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    user_s?: user_sUpdateOneWithoutAccount_sNestedInput
    sale_s?: sale_sUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sUncheckedUpdateWithoutCredit_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    id_user_account?: NullableIntFieldUpdateOperationsInput | number | null
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_s?: sale_sUncheckedUpdateManyWithoutAccount_sNestedInput
  }

  export type client_sUpsertWithoutCredit_sInput = {
    update: XOR<client_sUpdateWithoutCredit_sInput, client_sUncheckedUpdateWithoutCredit_sInput>
    create: XOR<client_sCreateWithoutCredit_sInput, client_sUncheckedCreateWithoutCredit_sInput>
    where?: client_sWhereInput
  }

  export type client_sUpdateToOneWithWhereWithoutCredit_sInput = {
    where?: client_sWhereInput
    data: XOR<client_sUpdateWithoutCredit_sInput, client_sUncheckedUpdateWithoutCredit_sInput>
  }

  export type client_sUpdateWithoutCredit_sInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_s?: sale_sUpdateManyWithoutClient_sNestedInput
  }

  export type client_sUncheckedUpdateWithoutCredit_sInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_s?: sale_sUncheckedUpdateManyWithoutClient_sNestedInput
  }

  export type payment_sUpsertWithWhereUniqueWithoutCredit_sInput = {
    where: payment_sWhereUniqueInput
    update: XOR<payment_sUpdateWithoutCredit_sInput, payment_sUncheckedUpdateWithoutCredit_sInput>
    create: XOR<payment_sCreateWithoutCredit_sInput, payment_sUncheckedCreateWithoutCredit_sInput>
  }

  export type payment_sUpdateWithWhereUniqueWithoutCredit_sInput = {
    where: payment_sWhereUniqueInput
    data: XOR<payment_sUpdateWithoutCredit_sInput, payment_sUncheckedUpdateWithoutCredit_sInput>
  }

  export type payment_sUpdateManyWithWhereWithoutCredit_sInput = {
    where: payment_sScalarWhereInput
    data: XOR<payment_sUpdateManyMutationInput, payment_sUncheckedUpdateManyWithoutCredit_sInput>
  }

  export type payment_sScalarWhereInput = {
    AND?: payment_sScalarWhereInput | payment_sScalarWhereInput[]
    OR?: payment_sScalarWhereInput[]
    NOT?: payment_sScalarWhereInput | payment_sScalarWhereInput[]
    id_payment?: IntFilter<"payment_s"> | number
    id_credit_payment?: IntNullableFilter<"payment_s"> | number | null
    payment?: FloatNullableFilter<"payment_s"> | number | null
  }

  export type credit_sCreateWithoutPayment_sInput = {
    id_credit: number
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
    account_s?: account_sCreateNestedOneWithoutCredit_sInput
    client_s?: client_sCreateNestedOneWithoutCredit_sInput
  }

  export type credit_sUncheckedCreateWithoutPayment_sInput = {
    id_credit: number
    id_account_credit?: number | null
    id_client_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
  }

  export type credit_sCreateOrConnectWithoutPayment_sInput = {
    where: credit_sWhereUniqueInput
    create: XOR<credit_sCreateWithoutPayment_sInput, credit_sUncheckedCreateWithoutPayment_sInput>
  }

  export type credit_sUpsertWithoutPayment_sInput = {
    update: XOR<credit_sUpdateWithoutPayment_sInput, credit_sUncheckedUpdateWithoutPayment_sInput>
    create: XOR<credit_sCreateWithoutPayment_sInput, credit_sUncheckedCreateWithoutPayment_sInput>
    where?: credit_sWhereInput
  }

  export type credit_sUpdateToOneWithWhereWithoutPayment_sInput = {
    where?: credit_sWhereInput
    data: XOR<credit_sUpdateWithoutPayment_sInput, credit_sUncheckedUpdateWithoutPayment_sInput>
  }

  export type credit_sUpdateWithoutPayment_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateOneWithoutCredit_sNestedInput
    client_s?: client_sUpdateOneWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateWithoutPayment_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_account_credit?: NullableIntFieldUpdateOperationsInput | number | null
    id_client_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type account_sCreateWithoutSale_sInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    user_s?: user_sCreateNestedOneWithoutAccount_sInput
    credit_s?: credit_sCreateNestedManyWithoutAccount_sInput
  }

  export type account_sUncheckedCreateWithoutSale_sInput = {
    id_account: number
    id_user_account?: number | null
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    credit_s?: credit_sUncheckedCreateNestedManyWithoutAccount_sInput
  }

  export type account_sCreateOrConnectWithoutSale_sInput = {
    where: account_sWhereUniqueInput
    create: XOR<account_sCreateWithoutSale_sInput, account_sUncheckedCreateWithoutSale_sInput>
  }

  export type client_sCreateWithoutSale_sInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    credit_s?: credit_sCreateNestedManyWithoutClient_sInput
  }

  export type client_sUncheckedCreateWithoutSale_sInput = {
    id_client: number
    id_account_client?: number | null
    address_client?: string | null
    name_client?: string | null
    valance_credit_client?: number | null
    credit_s?: credit_sUncheckedCreateNestedManyWithoutClient_sInput
  }

  export type client_sCreateOrConnectWithoutSale_sInput = {
    where: client_sWhereUniqueInput
    create: XOR<client_sCreateWithoutSale_sInput, client_sUncheckedCreateWithoutSale_sInput>
  }

  export type account_sUpsertWithoutSale_sInput = {
    update: XOR<account_sUpdateWithoutSale_sInput, account_sUncheckedUpdateWithoutSale_sInput>
    create: XOR<account_sCreateWithoutSale_sInput, account_sUncheckedCreateWithoutSale_sInput>
    where?: account_sWhereInput
  }

  export type account_sUpdateToOneWithWhereWithoutSale_sInput = {
    where?: account_sWhereInput
    data: XOR<account_sUpdateWithoutSale_sInput, account_sUncheckedUpdateWithoutSale_sInput>
  }

  export type account_sUpdateWithoutSale_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    user_s?: user_sUpdateOneWithoutAccount_sNestedInput
    credit_s?: credit_sUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sUncheckedUpdateWithoutSale_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    id_user_account?: NullableIntFieldUpdateOperationsInput | number | null
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUncheckedUpdateManyWithoutAccount_sNestedInput
  }

  export type client_sUpsertWithoutSale_sInput = {
    update: XOR<client_sUpdateWithoutSale_sInput, client_sUncheckedUpdateWithoutSale_sInput>
    create: XOR<client_sCreateWithoutSale_sInput, client_sUncheckedCreateWithoutSale_sInput>
    where?: client_sWhereInput
  }

  export type client_sUpdateToOneWithWhereWithoutSale_sInput = {
    where?: client_sWhereInput
    data: XOR<client_sUpdateWithoutSale_sInput, client_sUncheckedUpdateWithoutSale_sInput>
  }

  export type client_sUpdateWithoutSale_sInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUpdateManyWithoutClient_sNestedInput
  }

  export type client_sUncheckedUpdateWithoutSale_sInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    id_account_client?: NullableIntFieldUpdateOperationsInput | number | null
    address_client?: NullableStringFieldUpdateOperationsInput | string | null
    name_client?: NullableStringFieldUpdateOperationsInput | string | null
    valance_credit_client?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUncheckedUpdateManyWithoutClient_sNestedInput
  }

  export type account_sCreateWithoutUser_sInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    credit_s?: credit_sCreateNestedManyWithoutAccount_sInput
    sale_s?: sale_sCreateNestedManyWithoutAccount_sInput
  }

  export type account_sUncheckedCreateWithoutUser_sInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
    credit_s?: credit_sUncheckedCreateNestedManyWithoutAccount_sInput
    sale_s?: sale_sUncheckedCreateNestedManyWithoutAccount_sInput
  }

  export type account_sCreateOrConnectWithoutUser_sInput = {
    where: account_sWhereUniqueInput
    create: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput>
  }

  export type account_sCreateManyUser_sInputEnvelope = {
    data: account_sCreateManyUser_sInput | account_sCreateManyUser_sInput[]
    skipDuplicates?: boolean
  }

  export type account_sUpsertWithWhereUniqueWithoutUser_sInput = {
    where: account_sWhereUniqueInput
    update: XOR<account_sUpdateWithoutUser_sInput, account_sUncheckedUpdateWithoutUser_sInput>
    create: XOR<account_sCreateWithoutUser_sInput, account_sUncheckedCreateWithoutUser_sInput>
  }

  export type account_sUpdateWithWhereUniqueWithoutUser_sInput = {
    where: account_sWhereUniqueInput
    data: XOR<account_sUpdateWithoutUser_sInput, account_sUncheckedUpdateWithoutUser_sInput>
  }

  export type account_sUpdateManyWithWhereWithoutUser_sInput = {
    where: account_sScalarWhereInput
    data: XOR<account_sUpdateManyMutationInput, account_sUncheckedUpdateManyWithoutUser_sInput>
  }

  export type account_sScalarWhereInput = {
    AND?: account_sScalarWhereInput | account_sScalarWhereInput[]
    OR?: account_sScalarWhereInput[]
    NOT?: account_sScalarWhereInput | account_sScalarWhereInput[]
    id_account?: IntFilter<"account_s"> | number
    id_user_account?: IntNullableFilter<"account_s"> | number | null
    e_mail?: StringNullableFilter<"account_s"> | string | null
    password_?: StringNullableFilter<"account_s"> | string | null
    name_company?: StringNullableFilter<"account_s"> | string | null
    general_valance_account?: FloatNullableFilter<"account_s"> | number | null
  }

  export type credit_sCreateManyAccount_sInput = {
    id_credit: number
    id_client_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
  }

  export type sale_sCreateManyAccount_sInput = {
    id_sale: number
    id_client_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type credit_sUpdateWithoutAccount_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    client_s?: client_sUpdateOneWithoutCredit_sNestedInput
    payment_s?: payment_sUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateWithoutAccount_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_client_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    payment_s?: payment_sUncheckedUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateManyWithoutAccount_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_client_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sUpdateWithoutAccount_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    client_s?: client_sUpdateOneWithoutSale_sNestedInput
  }

  export type sale_sUncheckedUpdateWithoutAccount_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_client_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sUncheckedUpdateManyWithoutAccount_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_client_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credit_sCreateManyClient_sInput = {
    id_credit: number
    id_account_credit?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
    total_payment_acumulation?: number | null
    credit_state?: string | null
  }

  export type sale_sCreateManyClient_sInput = {
    id_sale: number
    id_account_sale?: number | null
    price_to_sale?: number | null
    price_to_real_product?: number | null
    product_name?: string | null
  }

  export type credit_sUpdateWithoutClient_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateOneWithoutCredit_sNestedInput
    payment_s?: payment_sUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateWithoutClient_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_account_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
    payment_s?: payment_sUncheckedUpdateManyWithoutCredit_sNestedInput
  }

  export type credit_sUncheckedUpdateManyWithoutClient_sInput = {
    id_credit?: IntFieldUpdateOperationsInput | number
    id_account_credit?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    total_payment_acumulation?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sUpdateWithoutClient_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_s?: account_sUpdateOneWithoutSale_sNestedInput
  }

  export type sale_sUncheckedUpdateWithoutClient_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_account_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sale_sUncheckedUpdateManyWithoutClient_sInput = {
    id_sale?: IntFieldUpdateOperationsInput | number
    id_account_sale?: NullableIntFieldUpdateOperationsInput | number | null
    price_to_sale?: NullableFloatFieldUpdateOperationsInput | number | null
    price_to_real_product?: NullableFloatFieldUpdateOperationsInput | number | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_sCreateManyCredit_sInput = {
    id_payment: number
    payment?: number | null
  }

  export type payment_sUpdateWithoutCredit_sInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type payment_sUncheckedUpdateWithoutCredit_sInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type payment_sUncheckedUpdateManyWithoutCredit_sInput = {
    id_payment?: IntFieldUpdateOperationsInput | number
    payment?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type account_sCreateManyUser_sInput = {
    id_account: number
    e_mail?: string | null
    password_?: string | null
    name_company?: string | null
    general_valance_account?: number | null
  }

  export type account_sUpdateWithoutUser_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUpdateManyWithoutAccount_sNestedInput
    sale_s?: sale_sUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sUncheckedUpdateWithoutUser_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
    credit_s?: credit_sUncheckedUpdateManyWithoutAccount_sNestedInput
    sale_s?: sale_sUncheckedUpdateManyWithoutAccount_sNestedInput
  }

  export type account_sUncheckedUpdateManyWithoutUser_sInput = {
    id_account?: IntFieldUpdateOperationsInput | number
    e_mail?: NullableStringFieldUpdateOperationsInput | string | null
    password_?: NullableStringFieldUpdateOperationsInput | string | null
    name_company?: NullableStringFieldUpdateOperationsInput | string | null
    general_valance_account?: NullableFloatFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}